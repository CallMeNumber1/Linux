疑问:

client.c与server-1.c

感觉发出和接受文件内容时都有问题

连接树莓派pi2`ssh -p 6532 ChongH@zentao.haizeix.tech`

端口:0-65536

soket套接字

TCP协议

	三次握手(建立连接)
	
	四次挥手(释放连接)

## SOCKET编程

- 主机字节序与网络字节序
  - 在将一个地址绑定到socket的时候,先将主机字节序转化为网络字节序.

create

 建立新套接字,bind listen

父进程和子进程执行同一片代码块

	子进程pid=0

server:

	192.168.1.40
	
	端口:8731

`perror("")`

- socket() 创建socket

```c
int socket(int domain, int type, int protool)
domain: AF_INET...
type: SOCK_STREAM...
```

- bind()绑定IP地址及端口

```c
int bind(sockfd, const struct sockaddr *addr, socketlen_t addrlen)
sockfd是调用socket返回的文件描述符
addr是只想数据结构sockaddr的指针,保存你的地址(即端口和IP地址)信息
addrlen设置为sizeof(struct sock)
```

- 相关结构体

```c
struct sockaddr_in{
    sa_family_t sin_family;
    in_port_t sin_portl
    struct in_addr sin_addr;
}
struct in_addr{
   uint32_t s_addr;
}
```

- 

```c
htons()将端口号由主机字节序转换为网络字节序的整数值
	myaddr.sin_port = htons(8731)
ntohl()相反
inet_addr()将一个IP字符串转换为一个网络字节序的整数值
	sockaddr_in.sin_addr.s_addr = inet_addr("192.168.1.2")
inet_ntoa()将一个sin_addr结构体输出成字符串
inet_aton(server_addr_string, &myaddr.sin_addr)
// 尝试转换由strptr所指的字符串,并通过addrptr存放二进制结果
int inet_pton(int family, const char *strptr, void *addrptr)

// 进行相反转换,从数值格式转换到表达格式
const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len)

```

- listen()监听socket

```c
int listen(int sockfd, int backlog);
backlog可以取20,即排队列中的数目
```

- connect()建立连接

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
addr是保存着目的地端口和IP地址的数据结构
```

- accept()接收连接 **产生新socket**

```c
int accpet(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
当有连线进来时,accept()会返回一个新的socket处理代码,往后的数据传送与读取都是经由新的socket处理
```

- close()关闭连接

`int close(int fd)`

- send 将数据发送到缓冲区
  - 返回值为发送了多少
  - 注意第三个参数不要用sizeof,**要用strlen**,即有多少发多少.

- recv 从缓冲区中接受数据
  - 返回值为-1,0,>0,为0时代表对方关闭连接,>0时为收到了多少字节

fork()产生一个子进程(分身)

父进程有的子进程都有

当pid=0时说明为子进程

recv返回值为



#### 客户端向服务端发送文件(内容)

- 服务端获取客户端IP

```c
ac_sockfd = accept(server_sockfd, (struct sockaddr*)&client_addr, &addr_len)
printf("%s", inet_ntoa(client_addr.sin_addr))
```

- fflush(stdout)清空输出缓冲区,并把缓冲区内容输出

- fread(array, size_t size, size_t count, fp)
  - 第二个参数为每次读取的元素大小
  - 第三个参数为做多读取到的元素个数
  - array为读入的数组,fp为要读的文件

**在数组结尾加个\0才能正常显示**

????返回值不是读取元素的个数,若读到,则为1,为何?

bzero(buffer, sizeof(buffer)) 清零