## C++

#### 两个+

- 数据类型
- 面向对象设计思想

#### 常量

- const
  - C语言中是只读变量
    - C语言中的enum是真正的常量
  - C++中才是真正的常量
    - const有作用域和类型检查
- boolean的运算
  - 非0`true`
  - 0`false`

- 三目运算符
  - 当左值用时,不能含有字面量
  - 都是变量时, 返回的是变量的引用

- 引用
  - 变量的小名, 新的别名
  - 使用方式
    - 声明一个变量的引用时必须初始化
      - 特殊:引用作为参数的时候可以不用初始化(传参过程中自动完成)
    - 别名的类型和原来类型相同
  - 大部分情况下引用可以代替指针
    - 特殊:作为传出参数时不能代替指针
    - 因为局部变量使用后销毁,因此取别名也没有用

```c++
int a = 5;
int &b = a;
使用举例:swap(int &a, int &b)
```

#### 函数默认值

- 从右往左
- 传参时参数的数量要大于默认参数的个数
- 当函数声明和实现分开写时
  - 声明的时候写上,定义的时候不用写也不能写
- 占位参数
  - 可以实现c向c++的兼容

```c++
void g(int = 0, int = 0, int = 0) {
    cout << "hello g" << endl;
}
int main() {
    g();
    g(1, 2, 3);
    return 0;
}
```

#### 函数重载

- 同一作用域
- 函数名相同
- 参数列表不同
  - 参数类型,个数,顺序
- 函数指针和函数重载一起用
  - 不仅参数列表要相同
  - 返回类型也要相同
- 编译器调用准则
  - 所有重载函数都作为备选对象
  - 编译器尝试寻找匹配函数
    - 精确匹配

#### new/delete

- 在堆空间申请单个变量/一组连续的空间

```cpp
//type可以是基本数据类型/类
type *name = new type
delete name
//给单个变量初始化
type *name = new type(value)
delete name
//申请一堆连续的空间
type *name = new type[length]
delete[] name
```

#### 类

- 先有对象,通过对象抽象出类
- 属性: 描述类的属性的变量
- 方法: 表示类的行为特性
- 作用域: 在类的同一个作用域中没有访问权限这个概念

#### 构造函数

- 默认提供无参构造函数

#### 构造函数的初始化列表

- 背景
  - 类属性可以用const修饰,因此普通初始化方法无法使用
  - 在构造函数中给private const变量赋初值不允许
  - const类型属性必须用初始化列表去初始化
- 使用初始化列表的情况
  - const成员属性
  - 类属性
    - 类中有带参数构造函数时
- 注意事项
  - 初始化列表的初始化顺序与成员属性的声明顺序相同
  - 初始化顺序与实际书写的位置无关
  - 初始化列表优先于函数体执行
- 当执行到构造函数的函数体时, 此对象已经生成了

```cpp
class Test {
    private:
        const int i;
        int a;
        Value v1;
    public:
        Test(int v1, int v2);
        int getI() {
            return i;
        }
};
Test::Test(int v1, int v2) : i(v1), a(v2), v1(1) {
    cout << "i = " << i << endl;
    cout << "a = " << a << endl;
}
```

#### 析构函数

- 无参数, 无返回值
  - 说明不可被重载
  - 一个类中只有一个析构函数
- 堆上的对象
  - new调用构造函数, delete调用析构函数

#### 构造函数构造顺序

- 单个对象
- 全局对象
  - C++标准没有定义全局对象的构造顺序,所以不同编译器结果不同
  - 没有固定顺序,没有统一标准
  - 因此尽量不要使用全局对象
- 对象构造顺序:先父母,再朋友,后自己
  - 析构函数顺序与构造相反

#### 拷贝构造函数

- 编译器默认提供一个,简单的值赋值
  - 浅拷贝, 拷贝后物理状态相同
  - 不涉及指针和内存相关操作时, 浅拷贝即可
- 用已经存在的一个对象初始化一个新的对象
- 手动实现时一定要写`深拷贝`
  - 浅拷贝会导致内存重复释放等问题
  - 深拷贝, 逻辑状态相同

#### 静态成员变量

- 属于整个类, 所有对象共享, 生命周期整个程序
- 可通过类名直接访问共有静态成员变量
- 访问级别

#### 静态成员方法

- 即类方法, 没有this指针
- 静态成员方法不能直接访问成员变量

#### 静态/成员方法比较

|              | 静态 | 普通 |
| :----------: | ---- | ---- |
| 所有对象共享 | √    | √    |
|  this'指针   | ×    | √    |
| 访问普通成员 | ×    | √    |
| 访问静态成员 | √    | √    |
| 通过类来调用 | √    | √    |
| 通过对象访问 | √    | √    |

- 对象在内存中属性是自己的, 方法是大家的

- 每个成员方法里都有一个this指针, 即对象地址

- 而静态成员函数没有this指针

- this:当前对象的指针 
  - 返回当前对象的某个值, 用的当前对象的某个值

#### const对象与方法

- const对象的性质
  - 属性都是只读的, 在编译期只读对象成员属性不能被改变
  - 只能调用const方法.`Type funcName() const {}`
- const方法与普通方法构成重载关系
- const成员方法内部只能调用const方法
- const成员方法中不能改变普通成员属性的值
- C++程序中直接用const变量中就是一个真正的常量, 而在类中作为属性时, 是只读的.



 :date:2018.01.08 周二

#### struct与class区别

- 默认访问权限, struct为public, class为private

#### 返回值优化

- 临时对象（也是匿名对象）
  - 生命周期只有当前行

- 当无参构造函数调用有参构造函数时会出现这种情况

```cpp
Test t[3] = {Test(), Test(100), Test(10)};
// 设计到临时对象，以及拷贝构造函数
Test t = Test(100)
// 先产生临时对象，再调用拷贝构造函数
// C++在编译时默认进行返回值优化,相当于t = 10
Test func() {
	Test t(100);
    return t;
}
Test t1 = func();
// 会调用两次拷贝构造
// c++返回值优化后,不调用拷贝构造,相当于 t1 = 100
```

- 关闭返回值优化

  `g++ test.cpp -fno-elide-constructors`

#### 组合

构造顺序：先父亲，后朋友，再自己（这句话是递归使用的）

- 其他类的对象当做当前类的成员
- 其他类对象的生命周期与当前类的对象相同
- 成员对象在用法上与普通成员相同

#### 继承

类与类之间的关系，单向的

代码复用

- 用法：`class A: 继承方式`

- 特点
  - 子类继承父类的所有属性和方法
  - 子类是一种特殊父类，子类对象可以当父类对象用
  - 子类可以添加自己的属性和方法，可以重写父类的方法

:date:2018.01.10 周四

- 继承方式
  - 工程上常用public

- 构造函数
  - 先构造父类，再构造子类
  - 默认调用方式：要求父类构造函数必须是无参或带默认参数的
    - 详见昨天演示代码
- **构造顺序**
  - 子类对象构造时需要先初始化父类属性，需要调用父类构造函数（自动，手动）
  - 构造函数执行顺序为`先父亲，后朋友，再自己`
  - 父类构造函数显式调用时必须在子类构造函数初始化列表中
  - 子类对象销毁时同样需要调用父类析构函数（只是自动调用）
  - 先构造的后析构
- **同名冲突**
  - 当子类定义了与父类同名属性时，优先使用子类的属性，编译器自动将父类的隐藏掉（实际仍存在），可使用**作用域分辨符**来使用父类的同名属性`b.A::i`
  - 子类和父类中同名方法不构成重载关系，是**重写**
    - 因为两个类位于不同作用域，而重载要求同一作用域
  - 使用作用域分辨符访问同名成员属性和方法

- 父子兼容
  - 子类是个特殊的父类
  - 子类对象可以初始化父类对象
  - 父类指针可以指向子类
  - 父类对象的引用可以引用子类对象

```cpp
B b;
A *p1 = &b; A &p2 = b;
```

