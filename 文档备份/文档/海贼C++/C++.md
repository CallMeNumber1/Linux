# C++

#### 两个+

- 数据类型
- 面向对象设计思想

#### 常量

- const
  - C语言中是只读变量，C语言中的enum是真正的常量
  - C++中才是真正的常量，const有作用域和类型检查
- boolean的运算
  - 非0`true`
  - 0`false`

- 三目运算符
  - 当左值用时,不能含有字面量
  - 都是变量时, 返回的是变量的引用

- 引用
  - 变量的小名, 新的别名
  - 使用方式
    - 声明一个变量的引用时必须初始化
      - 特殊:引用作为参数的时候可以不用初始化(传参过程中自动完成)
    - 别名的类型和原来类型相同
  - 大部分情况下引用可以代替指针
    - 特殊:作为传出参数时不能代替指针
    - 因为局部变量使用后销毁,因此取别名也没有用

```c++
int a = 5;
int &b = a;
使用举例:swap(int &a, int &b)
```

#### 函数默认值

- 从右往左
- 传参时参数的数量要大于默认参数的个数
- 当函数声明和实现分开写时
  - 声明的时候写上,定义的时候不用写也不能写
- 占位参数
  - 可以实现c向c++的兼容

```c++
void g(int = 0, int = 0, int = 0) {
    cout << "hello g" << endl;
}
int main() {
    g();
    g(1, 2, 3);
    return 0;
}
```

#### 函数重载

- 同一作用域
- 函数名相同
- 参数列表不同
  - 参数类型,个数,顺序
- 函数指针和函数重载一起用
  - 不仅参数列表要相同
  - 返回类型也要相同
- 编译器调用准则
  - 所有重载函数都作为备选对象
  - 编译器尝试寻找匹配函数
    - 精确匹配

#### new/delete

- 在堆空间申请单个变量/一组连续的空间

```cpp
//type可以是基本数据类型/类
type *name = new type
delete name
//给单个变量初始化
type *name = new type(value)
delete name
//申请一堆连续的空间
type *name = new type[length]
delete[] name
```

#### 类

- 先有对象,通过对象抽象出类
- 属性: 描述类的属性的变量
- 方法: 表示类的行为特性
- 作用域: 在类的同一个作用域中没有访问权限这个概念

#### 构造函数

- 默认提供无参构造函数

#### 构造函数的初始化列表

- 背景
  - 类属性可以用const修饰,因此普通初始化方法无法使用
  - 在构造函数中给private const变量赋初值不允许
  - const类型属性必须用初始化列表去初始化
- 使用初始化列表的情况
  - const成员属性
  - 类属性
    - 类中有带参数构造函数时
- 注意事项
  - 初始化列表的初始化顺序与成员属性的声明顺序相同
  - 初始化顺序与实际书写的位置无关
  - 初始化列表优先于函数体执行
- 当执行到构造函数的函数体时, 此对象已经生成了

```cpp
class Test {
    private:
        const int i;
        int a;
        Value v1;
    public:
        Test(int v1, int v2);
        int getI() {
            return i;
        }
};
Test::Test(int v1, int v2) : i(v1), a(v2), v1(1) {
    cout << "i = " << i << endl;
    cout << "a = " << a << endl;
}
```

#### 析构函数

- 无参数, 无返回值
  - 说明不可被重载
  - 一个类中只有一个析构函数
- 堆上的对象
  - new调用构造函数, delete调用析构函数

#### 构造函数构造顺序

- 单个对象
- 全局对象
  - C++标准没有定义全局对象的构造顺序,所以不同编译器结果不同
  - 没有固定顺序,没有统一标准
  - 因此尽量不要使用全局对象
- 对象构造顺序:先父母,再朋友,后自己
  - 析构函数顺序与构造相反

#### 拷贝构造函数

- 编译器默认提供一个,简单的值赋值
  - 浅拷贝, 拷贝后物理状态相同
  - 不涉及指针和内存相关操作时, 浅拷贝即可
- 用已经存在的一个对象初始化一个新的对象
- 手动实现时一定要写`深拷贝`
  - 浅拷贝会导致内存重复释放等问题
  - 深拷贝, 逻辑状态相同

#### 静态成员变量

- 属于整个类, 所有对象共享, 生命周期整个程序
- 可通过类名直接访问共有静态成员变量
- 访问级别

#### 静态成员方法

- 即类方法, 没有this指针
- 静态成员方法不能直接访问成员变量

#### 静态/成员方法比较

|              | 静态 | 普通 |
| :----------: | ---- | ---- |
| 所有对象共享 | √    | √    |
|  this'指针   | ×    | √    |
| 访问普通成员 | ×    | √    |
| 访问静态成员 | √    | √    |
| 通过类来调用 | √    | √    |
| 通过对象访问 | √    | √    |

- 对象在内存中属性是自己的, 方法是大家的

- 每个成员方法里都有一个this指针, 即对象地址

- 而静态成员函数没有this指针

- this:当前对象的指针 
  - 返回当前对象的某个值, 用的当前对象的某个值

#### const对象与方法

- const对象的性质
  - 属性都是只读的, 在编译期只读对象成员属性不能被改变
  - 只能调用const方法.`Type funcName() const {}`
- const方法与普通方法构成重载关系
- const成员方法内部只能调用const方法
- const成员方法中不能改变普通成员属性的值
- C++程序中直接用const变量中就是一个真正的常量, 而在类中作为属性时, 是只读的.



 :date:2018.01.08 周二

#### struct与class区别

- 默认访问权限, struct为public, class为private

#### 返回值优化

- 临时对象（也是匿名对象）
  - 生命周期只有当前行

- 当无参构造函数调用有参构造函数时会出现这种情况

```cpp
Test t[3] = {Test(), Test(100), Test(10)};
// 设计到临时对象，以及拷贝构造函数
Test t = Test(100)
// 先产生临时对象，再调用拷贝构造函数
// C++在编译时默认进行返回值优化,相当于t = 10
Test func() {
	Test t(100);
    return t;
}
Test t1 = func();
// 会调用两次拷贝构造
// c++返回值优化后,不调用拷贝构造,相当于 t1 = 100
```

- 关闭返回值优化

  `g++ test.cpp -fno-elide-constructors`

#### 组合

构造顺序：先父亲，后朋友，再自己（这句话是递归使用的）

- 其他类的对象当做当前类的成员
- 其他类对象的生命周期与当前类的对象相同
- 成员对象在用法上与普通成员相同

#### 继承

类与类之间的关系，单向的

代码复用

- 用法：`class A: 继承方式`

- 特点
  - 子类继承父类的所有属性和方法
  - 子类是一种特殊父类，子类对象可以当父类对象用
  - 子类可以添加自己的属性和方法，可以重写父类的方法

:date:2018.01.10 周四

- 继承方式
  - 工程上常用public

- 构造函数
  - 先构造父类，再构造子类
  - 默认调用方式：要求父类构造函数必须是无参或带默认参数的
    - 详见昨天演示代码
- **构造顺序**
  - 子类对象构造时需要先初始化父类属性，需要调用父类构造函数（自动，手动）
  - 构造函数执行顺序为`先父亲，后朋友，再自己`
  - 父类构造函数显式调用时必须在子类构造函数初始化列表中
  - 子类对象销毁时同样需要调用父类析构函数（只是自动调用）
  - 先构造的后析构
- **同名冲突**
  - 当子类定义了与父类同名属性时，优先使用子类的属性，编译器自动将父类的隐藏掉（实际仍存在），可使用**作用域分辨符**来使用父类的同名属性`b.A::i`
  - 子类和父类中同名方法不构成重载关系，是**重写**
    - 因为两个类位于不同作用域，而重载要求同一作用域
  - 使用作用域分辨符访问同名成员属性和方法

- 父子兼容
  - 子类是个特殊的父类
  - 子类对象可以初始化父类对象
  - 父类指针可以指向子类
  - 父类对象的引用可以引用子类对象

```cpp
B b;
A *p1 = &b; A &p2 = b;
```

当不使用虚函数时，编译器统一解释为父类的版本，这样不会出问题。

#### 对象模型

- 成员属性和成员方法分开存储
- sizeof为属性的大小
- class是特殊的struct，编译期看访问权限，运行时退化成了struct
- 成员属性是依次排列的，成员属性之间可能存在内存空隙
- 可以通过内存地址直接访问（说明访问权限只是告诉编译器，运行时仍然可以通过地址访问）

class的C语言实现

#### 多继承

**继承是简单的堆叠**

```cpp
例如C继承A，B，C的内存排布为：依次先A后B再C
特别的，当A和B中都有虚函数时，C中首部会分别增加A和B的虚函数指针（指针8字节）
```

多继承+父子兼容时

- 指向子类的父类指针会指向不同地方，父子兼容直接退化成父类

![2019-01-10 20-58-47屏幕截图](/home/chongh/图片/2019-01-10 20-58-47屏幕截图.png)

多继承问题

- 不知道调哪个函数
  - 使用作用域分辨符
- 一个对象可能有多个地址
- 数据冗余
  - 首先要在最底层子类构造函数中调用最顶层父类的构造函数

解决方案：虚继承，但工程上不好管理

#### 多态

不同对象产生不同行为

根据实际对象取判断调用的函数

virtual关键字

- 声明多态
- 被virtual修饰的函数具有多态性，叫虚函数
  - 相关概念：纯虚函数，抽象类，接口
- 父类中某函数声明后，子类中默认virtual

`注意：virtual不能修饰类方法（static）`

多态意义

- 在程序中表现出动态特性
- 在子类三种重写父类同名函数必须声明成虚函数（父类中声明），否则没有意义

多态实现原理

当有virtual时，编译器改变了对象的内存排布

1. 在类声明虚函数时，编译器会自动生成一个**虚函数表**
2. 虚函数是一个存储成员函数地址的数据结构
3. 虚函数表由编译器自动生成和维护
4. 被virtual修饰的虚函数会被放入虚函数表中
5. 存在虚函数时，每个对象会有一个指向虚函数表的指针并且此指针在对象的头部

- 在多态时，编译器会对类做一些改变，在头部增加虚函数表指针，对象内有个指向虚函数表的指针`vptr`，其中存的是要表现多态性函数的地址。占8个字节

静态联编：程序在编译期间就知道调用哪个函数（函数重载）

动态联编：程序在运行期间才知道调用哪个函数（函数重写）

#### 纯虚函数

- 纯虚函数没有函数体，同时在定义的时候，其函数名后面要加上“=0”

应用场景：定义接口

#### 抽象类

- 包含纯虚函数的类成为抽象类
- 对于抽象类来说，它无法实例化对象，而对于抽象类的子类来说，只有把抽象类中的纯虚函数全部实现之后，那么这个子类才可以实例化对象

#### 接口

- 没有任何成员属性
- 所有方法都是pubic的纯虚函数

#### 单继承+多接口

1.16课堂任务

- c语言实现继承
- 实现多态
  - 过程: 比如p->say()是一个虚函数，1.插指针，确定2.在构造函数中关联相关指针

#### C++中的强制类型转换

**reinterpret_cast<>**（两个不同类型进行强制类型转换时）

- dynamic_cast

和继承、虚函数相关的强制类型转换用`dynamic_cast`

```cpp
BaseA *p1
BaseB *pb = dynamic_cast<BaseB*>(p1)
```

泛型编程：包括函数模板和类模板

## 函数模板

 例如，编写一个交换函数时，可以使用`宏实现`和`函数实现`

	宏实现是通用的但安全性不足

	函数实现安全，但同样的功能要重载，有大量重复工作

因此引入函数模板的概念。

- 概念：一种泛型编程方式，不考虑数据类型

`template<typename T>`

template: 开始模板编程

typename: T是类型名

- 会进行两次检查：

  数据类型检查

- 意义
  - 函数模板能根据实参类型进行参数类型推导
  - 支持显示指定参数类型
  - 是c++中代码复用的一种形式

```cpp
例如：
template <typename T>
void my_sort(T *a, int len) {
    for (int i = 0; i < len; i++) {
        for (int j = i; j < len; j++) {
            if (a[i] > a[j]) {
                my_swap1(a[i], a[j]);
            }
        } 
    }
    return ;
}
string s[5] = {"c", "python", "java", "cpp", "c#"}；
my_sort(s, 5); 			// 自动类型推导
my_sort<string>(s, 5); 	// 显式指定类型
```

- 使用注意事项
  - 函数模板本身不支持隐式类型转换
  - 自动推导类型时，必须严格遵守类型匹配，而且不会进行隐式类型转换
  - 显式指定时，能够进行隐式类型转换
  - 多个类型参数时，返回值类型无法自动推导
  - 可以从左至右部分指定参数类型

```c
多类型参数部分指定参数例子：
template <typename T1, typename T2, typename T3>
T1 add(T2 a, T3 b) {
    return static_cast<T1>(a + b);
}
int r1 = add<int>(0.5, 0.3);				// 0
int r2 = add<int, float>(0.3, 0.6); 		// 0
int r3 = add<int, float, float>(0.5, 0.5);	// 1

```





#### 剩下课程：类模板、运算符重载、异常处理、强制类型转换