## 递推

#### 如何求解递推问题

1. **确定递推状态（最重要）**

   `符号表示`+`对符号的解释`才确定了递推状态

   对符号的解释不同会导致公式不同

   例如：f(n)代表第n个月兔子的总对数

2. 确定递推公式

3. 程序实现

   可以选择**递归(加记忆化)**去写，也可以选择**循环**去写

学习重点：别人是如何确定递推状态的，如何想到的

#### 兔子繁殖问题

会出现两个问题

1. 程序运行效率问题（递归过程加记忆化或改成逆向递推求解）
2. 程序计算结果超过整型表示范围，结果溢出（改成大整数求解）

#### 爬楼梯

f(n) = f(n - 2) + f(n - 3)

- 滚动数组的使用

数组只需开4位就行，循环使用，因为计算f(n)时最多只需要用到前3位空间

#### 墙壁染色

- 递推状态
  - `f[n][i][j]`代表n块墙壁，第一块涂颜色i，第二种涂颜色j，方案总数
- 递推公式
  - `f[n][i][j] = (k=0,1,2)f[n - 1][i][k](k!=j)`
  - 因为求n时只用到n-1，因此可使用滚动数组，开两个大小即可
- 确定初值
  - `f[1]`，1块墙壁，当第一块和最后一块颜色相同时才合法（$i==j$)
  - `f[2]`，2块墙壁，当第一块和最后一块颜色不同时才合法($i !=j$)

最终累加`f[n][i][j]`，由于墙壁是环形，i==j时不合法。

- 但计算时i==j的情况也要计算出来, 最后再求合法的方案

$\sum\limits_{i=0}^2\sum\limits_{j=0}^2f[n][i][j](i\neq{j})$

第二种思路

考虑共有 n块，

1. 如果此时第n-1块如果和第1块相同，此时第n块就有2种方案，并且第n-2块必然此时和第n-1块不同，这就是f(n-2)的方案数，此时为2*f(n-2)。

2. 如果此时第n-1块和第1块不同，那么不就是f(n-1)的方案数么，此时为f(n-1)

最后总结出递推公式：f(n)=f(n-1)+2*f(n-2)

#### 钱币问题

- 递推状态
  - `d[i][j]`代表用前i种钱币凑齐j元的方案总数
- 递推公式
  - `d[i][j] = d[i - 1][j] + d[i][j - w[i]]`
    - `d[i][j]`分成两部分：即不包含第i种钱币的方案总数和包含第i种钱币的方案总数
    - 关于`d[i][j - w[i]]`的理解：加入要凑19元，将5元拿出去，则变成了要用所有的钱币凑14元，则相当于一定拿了5元。所以是包含5元的方案总数

## 动规与递推区别

动态规划是求解最优化问题

而递推往往是求方法总数的问题

## DP入门

**动态规划问题是一类特殊的递推问题**

#### 数字三角形

- 可以从上往下求也可以从下往上求
- 递归状态定义不同，导致递推公式不同

#### 最长上升子序列

- 子序列可以是不连续的

#### 最长公共子序列

- 确定动归状态

  `dp[i][j]`代表A串长度i，B串长度j的最长公共子序列长度

- 确定状态转移方程

#### 切割回文

- 区间dp问题

- 动态规划是较大规模问题的答案，依赖于较小问题的答案，第一步要先找到最小规模问题的答案

- 动归状态

  `dp[i][j]`表示从i到j切多少刀

- 状态转移方程

  当i到j不是回文串`dp[i][j] = min(dp[i][k] + dp[k + 1][j] + 1) k=i,...,j-1`

  当i到j是回文串`dp[i][j] = 0 即当s[i] == s[j] && dp[i+1][j-1]==0`

上述做法为$O(n^3)$会超时，下面引入一个$O(n^2)$的做法

状态定义：`dp[i]`表示从长度为1的位置到长度为i的位置的最少切割次数

状态转移：如果j到i是回文串，`dp[i]=min(dp[i], dp[j-1] + 1)`;

解题思路：
          dp[len] ， s；
          先给dp数组赋值（0，1，2.....，len-1），这是最坏的打算，表示长度为len的字符串需要切割ln-1次；
          然后从s的第0位到第n位循环判断是否是回文（palindrome）：
                 若是，dp[n]=0（表示s[0]—s[n]不需要切割），继续判断0到n+1位是否是回文；
                 若不是，锁定n，判断从第i=1位到第n位是否为回文：
                        若是，比较dp[n+1]的值与dp[i]+1的值，选择最小的赋给dp[n+1]；

#### 0/1背包

- 动归状态

  `dp[i][j]`代表前i件物品，背包重为j时所获得的最大价值

- 状态转移方程

  分为选择了第i件物品和没有选择第i件物品

  `dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])`

  **其中选择了第i件物品时为**`dp[i-1][j-w[i]]+v[i]`代表只选择了一件i物品，剩下的在其他物品中选。这里也是与完全背包的区别

#### 完全背包

- 每件物品可以选多件

- 与0/1背包的区别，状态转移方程，当拿了第i件物品，为`dp[i][j-w[i]]+v[i]`，因为前i件里面可能拿了物品i也可能没拿物品i 

#### 多重背包

- 每件物品有限多件
- 可以改成0/1背包做（每个物品看成独立的）

## 数学归纳法

1. 验证$k_0$ 成立
2. 证明如果$k_i$成立，那么$k_{i+1}$也成立
3. 联合上述两步，证明由$k_0$->$k_n$成立

数学归纳法与动态规划

- 可用于证明动归状态的正确性

## 递推问题的求解方向

1. 我从哪里来

   比如`dp[i][j]`依赖的状态

   数字三角形、兔子繁殖问题、钱币问题、墙壁涂色

2. 我到哪里去

   当一个点变化时，用这个点更新所有能到达的点

   杂务（P1113）、神经网络（P1038）、旅行计划（P1137）

## 动归问题总结

1. 一类特殊的递推问题

2. 求解最优化问题

   最大、最小、最长

3. 最优子结构

   规模为n的最优解，取决于规模n-1的最优解

4. 无后效性

   之前的决策对后续决策无影响，**设计状态转移方程的关键**

   即求解父状态时不在乎子状态的方案，只告诉父状态一个最优值即可

动归的习题作业

## 动归优化分类

#### 状态优化

优化空间

- 去除冗余状态
  - 比如二维转一维
- 重新定义状态
  - 墙壁涂色问题

#### 转移优化

优化时间

例如：最长上升子序列、单调（队列、栈）优化、斜率优化、四边形不等式

#### 切割回文-优化

沿着区间DP的思想，固定区间起始位置，以每个位置作为结尾，只需关心最后一刀切在哪里

重新定义动归状态为`dp[i]代表从1到i最少切多少刀`

确定状态转移方程为：

	因为找的是最后一刀切的位置，因此k+1～i是回文串

```latex
dp(i) = min{dp[k] + 1} | S[k + 1...i]是个回文串
```

dp方程状态数n，每次转移要循环一遍k，复杂度为n。每找到一个k要判断k+1～i是否是回文串，时间复杂度也是O(n)，因此判断一个串是否为回文串要提前处理

![1548172704243](/tmp/1548172704243.png)

#### 最长上升子序列-优化

状态定义不变dp[i]代表以i位结尾的上升子序列最长长度

增加一个len数组，动态更新，记录的是长度为j序列的末尾最小值

- 优化了状态转移过程为logn，因为整体复杂度由O(n^2)变为O(logn)

#### 01背包-优化 9_2.cpp

#### 完全背包-优化 10_2.cpp

#### 多重背包二进制优化

朴素的是拆成k个1，用来组合得到选择这件物品数量的所有可能性

优化拆分方法



## 问题

全局数组和局部数组区别？

	开二维数组时，10000大小开在全局没问题，开在局部会段错误？？

#### 全局变量和局部变量存储位置区别

- 全局变量存储在内存中的静态区，而局部变量存储在栈区
- C语言程序占用的内存分为：
  1. 堆区：由程序员分配和释放，比如malloc
  2. 栈区：由编译器自动分配和释放，一般用来存放局部变量、函数参数
  3. 静态区：用于存储全局变量和静态变量
  4. 代码区：用来存放函数体的二进制代码
- 总之，当需要声明一个超过万级的变量时，最好放在全局变量，否则会段错误