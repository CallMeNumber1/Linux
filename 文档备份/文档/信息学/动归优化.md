## 动归优化分类

#### 状态优化

优化空间

- 去除冗余状态
  - 比如二维转一维
- 重新定义状态
  - 墙壁涂色问题

#### 转移优化

优化时间

例如：最长上升子序列、单调（队列、栈）优化、斜率优化、四边形不等式

#### 切割回文-优化

沿着区间DP的思想，固定区间起始位置，以每个位置作为结尾，只需关心最后一刀切在哪里

重新定义动归状态为`dp[i]代表从1到i最少切多少刀`

确定状态转移方程为：

```
因为找的是最后一刀切的位置，因此k+1～i是回文串
```

```latex
dp(i) = min{dp[k] + 1} | S[k + 1...i]是个回文串
```

dp方程状态数n，每次转移要循环一遍k，复杂度为n。每找到一个k要判断k+1～i是否是回文串，时间复杂度也是O(n)，因此判断一个串是否为回文串要提前处理

![1548172704243](/tmp/1548172704243.png)

#### 最长上升子序列-优化

状态定义不变dp[i]代表以i位结尾的上升子序列最长长度

增加一个len数组，动态更新，记录的是长度为j序列的末尾最小值

- 优化了状态转移过程为logn，因为整体复杂度由O(n^2)变为O(logn)

#### 01背包-优化 9_2.cpp

降维

- 减行，第i个物体的更新，只依赖于第i-1个的物体的结果

  ```
  所以可以用滚动数组，每次只存i和i-1时候的值 （可得：`dp[n][W] → dp[2][W] `）
  ```

- 删行  第i个物体在容积为j状态的更新，只依赖i-1物体容量里j-w[i]的状态的结果

  所以，从后面开始向前更新，则求j位置时候，j-w[i]的值依旧为i-1时候的值（可得：`dp[n][W] → dp[W] `）

```c
for(i = 1; i<=n; i++)
{
    for(j = W; j>=w[i]; j--) //从后向前，此时dp[j-w[i]]相当于dp[i-1][j-w[i]]
    {
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```

#### 完全背包-优化 10_2.cpp

什么只是换了遍历方向就可以由01背包变成了完全背包呢，这样不是就利用了当前这一次更新数组的左边的数据了吗，上一次01背包为了避免这种情况发生专门从右向左写数据，而这个刚好相反，我这次写数据从左往右写，前面写了以后，留给后面的作参考，因为随着一位数组横向写入数据越多，j也在变大，j变大，就可以看看有没有东西可以继续塞进去，因为01背包一个物品放进去后就不能再用了，而完全背包还可以利用，所以当前这一次对某个物品做出选择后还可以继续选择，也就是说还可以再放第2个该物品，第三个，等等，所以完全背包每次做出选择是取决于当前这一步的，而01背包每次做出选择是取决于上一步的。主要就是因为当前这一步一个物品放过以后，表格逐渐向右填写，随着可放空间的增加，可以判断这一步是否还可以再放一个当前的物品。跟前面那个求出当前可放的最大物品数，然后从0个放到最大个，本质是一样的。

#### 多重背包二进制优化

朴素的是拆成k个1，用来组合得到选择这件物品数量的所有可能性

优化拆分方法

#### 多重背包单调队列优化

> 未完全理解

首先按照余数系将所有重量进行切分，所有状态加在一起为背包总重量Ｖ

```
余数系:`0~v[i]-1`
```

对于每一个状态确定，为O(1)复杂度(单调队列)

单调队列维护区间最值（头部）

```
即　一个区间内部每次会进来一个元素，出去一个元素，进来一个元素之后要很快知道区间最大值
```

总时间复杂度为O(nV)

#### 扔鸡蛋问题优化

> 未完全理解

此类问题优化方法：`值和状态互换`

	`dp[i][j] = k --> d[i][k] = j`(要求j和k相关)

状态定义：`dp[i][k]`代表i个鸡蛋测k次，最多能测多少层楼

状态转移方程：`dp[i][k] = dp[i][k-1]+dp[i-1][k-1]` (第一个鸡蛋在第k层扔，碎了则往下测，没碎则去上面测)

![1549686452627](/tmp/1549686452627.png)

最后答案在`dp[n][k]`中找第一个k，大于m。因为当k大于m时，最多可以测超过m层楼了，则说明m层楼测的次数肯定不超过k。（m和k正相关）

#### 矩形问题

- $O(n^4)$做法

二维前缀和优化，每次把矩形中白色格子当做数值1，黑色当做数值0，判断子矩阵数值和与格子数量是否相等

- $O(n^3)$做法

每次确定一个左上角坐标，考虑以当前点作为左上角坐标的合法子矩阵数量。即考虑右下角坐标到底落在什么位置

- $O(n^2)$做法（先理解$O(n^3)$）单调栈优化

 单调栈：维护某个数字最近的比它大或比它小的数字

`f[i][j]`代表从当前位置向下数，白色格子数量

`dp[i][j]`为以此点为左上角坐标的合法子矩阵数量

找到`(i,j)`右边最近的一个点`(i,k)`,使得`f(i,k)<f(i,j)`，对于这种最小关系的维护，使用**`单调递增栈`**，整体时间复杂度O(n)，均摊时间复杂度为O(1).

即每个`dp[i][j]`的计算是O(1)的，状态数为$n^2$个，每次转移O(1)

#### 古老的打印机

- $O(n^2)$做法

动归状态：`dp[i]`代表打印到第i个字符的最小消耗

状态转移方程：$dp[i]=min(dp[j]+(sum[i]-sum[j])^2+M),j=[0,i-1]$

其中sum是前缀和数组

- 斜率优化

![1549705914170](/tmp/1549705914170.png)



满足这个关系，则说明j点比k点优