## 主要目标

- 了解什么是二分,什么是三分查找
- 二分查找通用问题模型

## 排序算法为什么这么重要(密训)

#### 熵

- 不仅可以表示系统的混乱程度

- 计算机中表示用多少二进制位能表示一个系统的全部状态
- 问题系统解决的难易程度和熵有关系,熵越大,问题越难解决
- 一个问题解决的难易程度和问题中信息的排列有关,因此有序时问题更容易解决

**而排序,就是在减小问题的系统熵,当熵减小的一定程度,问题就变为可解决的问题.**

#### 结论及思考

- 越高级的算法,依赖的前提条件往往越多,需要的系统熵往往越小
  - 例如二分查找,则需要有序作为前提
  - 而冒泡排序,则是更为万金油的排序
    - 例如链表排序,只能冒泡
- 排序算法之所以重要,是因为可以显著降低问题的系统熵,往往能将一些问题简化.

## 授课内容

#### 二分查找

- 思维转换,用来求**单调函数的求解问题**
  - 即给定y(值)求x(下标)的问题
- 单调函数就代表那个有序的数组

通常情况下的二分查找

```cpp
int binary_search1(int *num, int n, int x) {
    int head = 0, tail = n - 1, mid;
    while (head <= tail) {
        mid = (head + tail) >> 1;
        if (num[mid] == x) return mid;
        if (num[mid] > x) tail = mid - 1;
        else head = mid + 1;
    }
    return -1;
}
```

#### 两类二分问题(重要)

1. **前面一堆1,后面一堆0的问题,要找最后一个1**

   - 初始

     - `min=-1,max是尾指针`

       为了防止全0的情况，将min指向虚拟头结点，当找不到时返回-1

     - `mid = (max + min + 1) / 2` 

       取两个相邻的后面那个，防止出现死循环

       例如：min=4，max=5，前1后0时，不采用上面的方式计算mid会死循环

   - 调整
     - `如果arr[mid] == 1,min = mid`，这样不会错过答案
     - `如果arr[mid] != 1max = mid - 1`
     - `如果min==max，找到结果`
     - 在头部加一个虚拟节点,当找不到时可返回-1

2. **前面一堆0,后面一堆1，要找到第一位1**

   - 初始

     - `min指向头指针，max指向虚拟尾指针`

       因为整个数组可能全0，因此max指向虚拟尾指针来处理这种非法情况

     - `mid = (min + max) / 2`

       这种情况就不必特殊处理中间位置的计算方式了

   - 调整
     - `arr[mid] != 1, min = mid + 1`
     - `arr[mid] == 1, max = mid`，防止错过答案
     - 如果`min==max`,找到结果
     - max指向最后位置后面的位置,用来实现当找不到时返回-1

#### 三分查找

- 用来求解凹凸函数的极值点求解问题

- 求解凸函数
  - 按较小的值更新,才不会错过极值点

#### 二分查找和三分查找

- 区别
  - 区间的缩小速度不同,二分每次缩小二分之一,三分每次缩小三分之一

- 分的到底是什么?
  - **问题求解规模**

#### 分块查找（计算客）

- 要求整个线性表是分块有序的，而在每一个子表中，元素的排列是随意的
- 优缺点
  - 由于子块中的元素是随意排序的，只要找到对应的块就能直接进行插入和删除操作，而不需要移动其他的元素，适用于线性表需要频繁的动态变化的情况
  - 缺点是需要一定的内存空间来存放索引表并且要对索引表进行排序

## 哈希表

二分、三分是用来查找的算法，哈希表是用来进行查找的数据结构

哈希:**高维(状态数多的空间)到低维的映射**,因此冲突是必然的,解决冲突是必然存在的

- 没有固定的形状,有一套指导思想
- 哈希函数
  - 有无数个
  - 将任意类型元素映射为一个指定数字
  - 直接定址法,除留余数法
- 冲突处理方法
  - 四大类：**开放地址法**,**拉链法**,再哈希法,建立公共溢出区域
  - 开放地址法：用某种规则再去算一个位置（线性探测、二次探测等）
  - 如果元素要存的位置已有元素

#### 实例

- 字符串哈希函数BKDRHash

- 冲突处理方法
  - 拉链法较为简单（链表头插法即可）
  - 或开放定址法
    - 使用二次探测法
- 最后& 0x7fffffff
  - 是int最大值，即INT_MAX

#### 洗牌问题

- 一副扑克牌,每次洗牌都从中抽取一张放在牌顶,重复进行54次,问此种方式是否是随机洗牌.随机洗牌指的是每幅牌面出现的概率相同.
  - 每个位置都有54种可能,一共54张牌,则洗牌的方式有$54^{54}$种,而洗完牌后的序列有$54!$种,因此不是一一对应,所以洗牌后每种序列出现的次数不相等,因此不是随机洗牌

#### 课下阅读

- 哈希函数
  - APHash
  - ZobristHash
    - 各种棋类程序中判断历史局面是否存在的算法
    - 按位异或运算的性质

了解哈希函数的使用是有场景的