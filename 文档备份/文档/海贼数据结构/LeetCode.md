# LeetCode

## 链表

- 链表排序用冒泡排序(正好链表有顺序特性)
- 141
  - 链表判环
  - p走1步,q走2步,若p,q相遇则链表有环.
- 160
  - 留有疑问，船长做法有bug
- 202
  - 逻辑上的链表结构

  - 整形范围内各位数的平方和最大时为81 * 9 = 729,(当数字999999999)九个9
  - 因此将每个状态看成链表中的节点时,最多有731个节点(加上初始和结束状态)
    - 可用此来当做链表有环的条件 

  - 链表判环:
    - p走1步,q走2步,若p,q相遇则链表有环.

```
意义:
数据结构分两方面,逻辑上的和物理上的.
本题目为逻辑上的数据结构
```

- 234

- 237
  - 当链表中节点内容被覆盖时,也相当于删除了节点本身

## 栈与队列

:date:2019-02-09

#### 20 括号匹配

栈的基操

#### 232 用队列实现栈

两个队列可以实现栈的操作

#### 225 用栈实现队列

两个栈可以实现队列的操作

## 树与二叉树

:date:2019-02-09

标三角号 **:small_red_triangle:** 的为不能独立完成的

#### 100 判断两棵树是否相同

两棵树结构相同且节点的值对应相同则为相同的树

递归判断即可

#### 101 判断一棵树是否是对称的

和100题相似

#### 102 二叉树层序遍历

一般使用队列bfs实现

> 船长演示代码使用dfs实现

#### 104 二叉树最大深度

简单题，递归计算即可

#### 107 层序遍历的逆转 :small_red_triangle:

相似问题：102题

> 借鉴的别人优秀做法
>
> 自己的做法在面临数据量大的用例时会报运行错误，猜测是内存占用过多？

#### 110 判断二叉树是否平衡

平衡条件为两个子树的深度差不超过1

较简单

```cpp
// 船长演示代码
int getHeight(struct TreeNode *root) {
    if (root == NULL) return 0;
    int l = getHeight(root->left);
    if (l < 0) return -2;
    int r = getHeight(root->right);
    if (abs(l - r) > 1) return -2;
    return (l > r ? l : r) + 1;
}
bool isBalanced(struct TreeNode* root) {
    if (root == NULL) return true;
    return getHeight(root) > 0;

}
```

#### 112 二叉树上的路径和

判断二叉树上是否存在一条根节点到叶子节点的路径，总和等于给定的值

递归计算即可

```cpp
if (root == NULL) return false;
    if (root->left == NULL && root->right == NULL && sum == root->val) return true;
    return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);
```

#### 111 二叉树最小深度

最小深度定义为由根节点到叶子节点路径的最小长度

递归计算即可，但要注意特判，因为求的是到叶子节点路径的最小长度，不包含叶子节点的路径，即使最短也不是答案

#### 226 逆转二叉树

递归交换二叉树的左右孩子即可

#### 235 LCA 最近公共祖先 :small_red_triangle:

> 船长代码 学习递归程序设计的思想

#### 257 二叉树所有路径

返回根节点到叶子节点的所有路径

- 297


## 排序与查找

#### 1 两数之和

- 排序后,设置头尾指针
- 如果相加大于x,则减小尾指针,若相加小于x,则增大头指针

#### 3 最长不重复子串

- 第一种方法,运用了hash表的思想，len 以当前字符为结尾的最长不重复子串长度，pos数组记录了每个字母最后出现的位置

- 第二种方法，二分，看成前1后0的问题。从长度1～strlen(s)二分字符串长度是否满足条件

#### 4 两个有序数组的中位数

- 二分
- 自己的做法：开了第三个数组

#### 35 查找插入位置

- 二分，前1后0

#### 38 Count and Say 

> 	待完成

#### 88

- 归并排序倒着来
- memcpy用法

```
memcpy(dest, src, sizeof()*n);
```

#### 217

- 用哈希表时，要注意得到的hash值要为非负数，否则作为下标时会出错

  `hash & 0x7fffffff`能保证是一个非负数

  一种思路：可封装成结构体，加一个empty字段标志是否为空

  > 待完成：数组好慢，改成链表

- 使用C++的set很容易实现

#### 219

> 	待完成

#### 378 杨氏矩阵第k小元素 

思路：二分。首先让head指向第一个元素（最小值）,tail指向最后一个元素（最大值），然后得到mid值，对于每一个mid值，内层循环计算有多少个数小于mid，如果`cnt==k`则得到答案为mid。

内层循环找到一个阶梯型，每次时间复杂度O(n + m)

原因：外层循环为二分，因此共logn次；假设n为行，m为列，内层循环从第一行扫到最后一行`i=0~n-1`，找出一个阶梯型，因此总共在列上执行了m次运算。解释如下：比如第一行`j=m-1`，当大于mid值时，`j--`，因此第二行从`j`的位置继续判断即可，而不需要从`m-1`的位置重新比较（根据杨氏矩阵的性质很容易得到）`即matrix[0][m-1]>mid,则matrix[1][m-1]肯定大于mid，因为矩阵向下递增`，所以得到内层循环在列上总共有`m`次运算.

#### 杨氏矩阵

- 横排有序且纵排有序

- 二分的思想就是找到一个位置,两侧截然相反的性质
- 在杨氏矩阵中查找一个数,则可以从右上角或者左下角开始,因为这两个点都具有以下性质:
  - 以右上角为例
  - 左边的值都小于它,右边的值都大于它

#### 问题中的升维与降维

- 解决问题的时候可以降维,思考问题可以升维
- 问题在低维度解决不了,可以升维思考,比如求两数之和
  - 右上角相当于尾指针,左上角相当于头指针
  - 可以看出不会发生漏解的情况

![2018-11-08 20-34-16屏幕截图](/home/chongh/图片/2018-11-08 20-34-16屏幕截图.png)

#### 二分查找的价值

- 两个思维框架
  - 某个具体问题可以转化成这个思维框架
  - 对于判定很容易,求解很困难的问题
  - 前1后0,用于求解最大值问题
  - 前0后1,用于求解最小值问题

#### 船长经验与思考

- 实力与技巧

- 创造性思维
  - 直觉加上证明手段

## 并查集

:date:2019-02-09

#### 128 最长连续序列

- 130

#### 200 小岛数量

#### 547 朋友圈

#### 684 冗余关系

- 685

2018.011.19

## 问题

#### leetcode378

- 杨氏矩阵

  杨氏矩阵如何解决`两数之和`问题

  	需要先进行排序

- 160 链表交点

  - 船长做法有bug

- 217

  - 使用哈希表时，要注意得到的hash值要为非负数，否则作为下标时会出错

    `hash & 0x7fffffff`能保证是一个非负数

  - 整数哈希时，如果不用拉链法，用数组实现的话，初值应该如何设置