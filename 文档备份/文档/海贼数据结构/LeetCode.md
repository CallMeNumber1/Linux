# LeetCode

#### 链表

- 链表排序用冒泡排序(正好链表有顺序特性)
- 141
  - 链表判环
  - p走1步,q走2步,若p,q相遇则链表有环.
- 160
  - 留有疑问，船长做法有bug
- 202
  - 逻辑上的链表结构

  - 整形范围内各位数的平方和最大时为81 * 9 = 729,(当数字999999999)九个9
  - 因此将每个状态看成链表中的节点时,最多有731个节点(加上初始和结束状态)
    - 可用此来当做链表有环的条件 

  - 链表判环:
    - p走1步,q走2步,若p,q相遇则链表有环.

```
意义:
数据结构分两方面,逻辑上的和物理上的.
本题目为逻辑上的数据结构
```

- 234

- 237
  - 当链表中节点内容被覆盖时,也相当于删除了节点本身


## 排序与查找

#### 1 两数之和

- 排序后,设置头尾指针
- 如果相加大于x,则减小尾指针,若相加小于x,则增大头指针

#### 3 最长不重复子串

- 第一种方法,运用了hash表的思想，len 以当前字符为结尾的最长不重复子串长度，pos数组记录了每个字母最后出现的位置

- 第二种方法，二分，看成前1后0的问题。从长度1～strlen(s)二分字符串长度是否满足条件

#### 4 两个有序数组的中位数

- 二分
- 自己的做法：开了第三个数组

#### 35 查找插入位置

- 二分，前1后0

#### 38 Count and Say 

> 	待完成

#### 88

- 归并排序倒着来
- memcpy用法

```
memcpy(dest, src, sizeof()*n);
```

#### 217

- 用哈希表时，要注意得到的hash值要为非负数，否则作为下标时会出错

  `hash & 0x7fffffff`能保证是一个非负数

  一种思路：可封装成结构体，加一个empty字段标志是否为空

  > 待完成：数组好慢，改成链表

- 使用C++的set很容易实现

#### 219

> 	待完成

#### 378 杨氏矩阵第k小元素 

思路：二分。首先让head指向第一个元素（最小值）,tail指向最后一个元素（最大值），然后得到mid值，对于每一个mid值，内层循环计算有多少个数小于mid，如果`cnt==k`则得到答案为mid。

内层循环找到一个阶梯型，每次时间复杂度O(n + m)

原因：外层循环为二分，因此共logn次；假设n为行，m为列，内层循环从第一行扫到最后一行`i=0~n-1`，找出一个阶梯型，因此总共在列上执行了m次运算。解释如下：比如第一行`j=m-1`，当大于mid值时，`j--`，因此第二行从`j`的位置继续判断即可，而不需要从`m-1`的位置重新比较（根据杨氏矩阵的性质很容易得到）`即matrix[0][m-1]>mid,则matrix[1][m-1]肯定大于mid，因为矩阵向下递增`，所以得到内层循环在列上总共有`m`次运算.

#### 杨氏矩阵

- 横排有序且纵排有序

- 二分的思想就是找到一个位置,两侧截然相反的性质
- 在杨氏矩阵中查找一个数,则可以从右上角或者左下角开始,因为这两个点都具有以下性质:
  - 以右上角为例
  - 左边的值都小于它,右边的值都大于它

#### 问题中的升维与降维

- 解决问题的时候可以降维,思考问题可以升维
- 问题在低维度解决不了,可以升维思考,比如求两数之和
  - 右上角相当于尾指针,左上角相当于头指针
  - 可以看出不会发生漏解的情况

![2018-11-08 20-34-16屏幕截图](/home/chongh/图片/2018-11-08 20-34-16屏幕截图.png)

#### 二分查找的价值

- 两个思维框架
  - 某个具体问题可以转化成这个思维框架
  - 对于判定很容易,求解很困难的问题
  - 前1后0,用于求解最大值问题
  - 前0后1,用于求解最小值问题

#### 船长经验与思考

- 实力与技巧

- 创造性思维
  - 直觉加上证明手段





2018.1.19

## 问题

#### leetcode378

- 杨氏矩阵

  杨氏矩阵如何解决`两数之和`问题

  	需要先进行排序

- 160 链表交点
  - 船长做法有bug

- 217

  - 使用哈希表时，要注意得到的hash值要为非负数，否则作为下标时会出错

    `hash & 0x7fffffff`能保证是一个非负数

  - 整数哈希时，如果不用拉链法，用数组实现的话，初值应该如何设置