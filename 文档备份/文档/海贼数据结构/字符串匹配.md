## 字符串匹配算法

- 母串, 模板串

#### 暴力匹配算法

- 逐位匹配,时间复杂度O(m*n)
- 优化手段

  - 可以根据模式串的信息去加速匹配的过程

- 例子:

  ![2018-12-30 14-51-04屏幕截图](/home/chongh/图片/2018-12-30 14-51-04屏幕截图.png)

  当模式串匹配到第6位失配时,模式串可以直接向后跳动三位重新对齐匹配,且前两位一定匹配成功;并且有3+2=5(6-1).

  	

#### KMP算法

- **母串的指针是不会往回跳的**
  - 模式串的信息导出的两个值为n-1, n为失配的位置
  - 因为相加为n-1,因此母串的指针是不动的或者向后动的
  - 节省了大量匹配操作

![2019-01-02 16-11-25屏幕截图](/home/chongh/图片/2019-01-02 16-11-25屏幕截图.png)

- next数组:以当前作为末尾公共子串的长度
  - 以此字符作为末尾, 可以一直匹配到模式串的哪一个字符
  - 每个位置都可以记录一个信息, 指导模式串的指针如何跳
  - 当失配后,模式串指针跳到第几位去和母串指针进行匹配,找到两个指针重新对齐的位置
  - 如果谁都匹配不上,记为-1
  - 顺着第n位前面去找到Tb这种结构,使得Tb尽可能长的与Ta进行匹配

 next数组在调整模式串的指针, 母串的指针不动或向后

- next数组的生成过程
  - 是一个递归过程,是模式串的自我匹配过程
  - 把模式串拷贝出来一份

- 例如:

  ![2018-12-30 15-47-22屏幕截图](/home/chongh/图片/2018-12-30 15-47-22屏幕截图.png)

  - e和d不匹配,则去找d的前一位的next值,与next值+1的位置比较 若还不匹配,继续找,直到匹配.

- 需要理解的关键

  从暴力算法到KMP中间有个聪明的做法

  其中两个数字,向后跳多少位,以及已有多少位对齐,以及相加为n-1

  再去理解为何母串指针不动

  再看模式串的指针应该跳到哪个位置

  next数组在调整模式串的指针

#### SUNDAY算法

- 最快复杂度为(m/n)
  - 即每次失配都往后跳模式串的长度个数
- 找失配的字符最后一次在模式串出现的位置,之后对齐
  - 因此不会错过正确答案(反证法可证明)
- 黄金对齐点(标注的不是母串和模式串的指针)
  - 相关字符出现在第几位,母串指针往后跳几位

#### SHIFT-AND算法

- 时间复杂度O(n)
- **d数组**
  - **二进制是倒着写的**(低位在前)
  - 如何判断一个字符在第n位是否出现过
  - 1左移n位,和此数与运算,对应位置为1则出现过
    - 位运算基操
- **在母串匹配过程中,两个公式**
  - 记录一个状态P
  - 母串进来一个字符, 就计算一下得到一个新的值
  - 如果P这个数字的第n位为1, 说明整个模式串在母串中找到了匹配的位置
  - P的相应位置为n,代表以此字符为结尾可以匹配模式串的前n位

```cpp
公式里面都是整型值
母串S
P = (P << 1 | 1) & d[s[i]]
P & (1 << (n - 1)) ?= 1
```

- 以新进来的字符作为结尾,能够匹配模式串前三位的前提
  - 前一个状态匹配两位
  - 当前字符必须在模式串第三位上出现过
- 第一个公式:
  - &运算前表示有可能匹配多少字符,做完&运算才表示一定能匹配多少个
- 第二个公式
  - 代表匹没匹配成功
- P记录了多种状态,多种状态是同时往下推的
- NFA:非确定性有限状态自动机

一个模式串一旦整理成状态码,就和原来的模式串没有任何关系了

之后匹配过程中就是二进制运算左移或与了

- 正则匹配
  - 整理状态码的时候,每一个位置(列)可以有多个字符

#### 时间复杂度对比

![2019-01-02 20-31-57屏幕截图](/home/chongh/图片/2019-01-02 20-31-57屏幕截图.png)

#### 单调栈

- 维护最近偏序关系
- 单调递增栈(维护左边第一个比它小的)
  - 当要压栈时, 把所有比它大的元素弹出

- 例题:找出能切出的最大矩形

![2018-12-30 17-29-18屏幕截图](/home/chongh/图片/2018-12-30 17-29-18屏幕截图.png)

```c
思路
```

- 矩形
  - 对于i,j,先求出向下的白色格子数
  - dp值以它作为左上角点能形成的合法矩阵的数目





读新闻

业界论文,前瞻性

锻炼思维方式

知道所学的职业哪里是有价值的,才能让自己的职业有价值

语言本身价值一定,重要的是语言的使用方式



快速傅里叶变换

- 求两个多项式相乘的每个系数
  - O(n)的复杂度解决
  - 即将一个二维矩阵乘以一维矩阵的时间复杂度变为O(n)！！！

#### 字典树Trie

![2019-01-03 09-46-02屏幕截图](/home/chongh/图片/2019-01-03 09-46-02屏幕截图.png)

- 节点是集合,边是关系
- 红色节点代表此集合中有以此前缀为单词的词,即此节点中有元素独立成词

- 基本性质
  - 根节点是全集
  - **每条边代表一个字母**
  - 从根节点到某一节点上.路径上经过的字符连接起来,就是该节点对应的字符串
  - 红点是独立成词
- 排序
  - 时间复杂度可以是O(n)的,n是单词中包含字符的总数量
  - 将这些单词插入字典树中, 按顺序访问出来, 就已经排好序了
  - 也可用于整数排序
    - 但要先将整数长度补齐(因为若按字典序,9大于100)
- 结构定义
  - 节点中存储的值
  - 可以指向多少个孩子, 即边集(next[]数组)
- 结构操作
  - 插入
  - 查找
- 作用:单词查找,字符串排序





## LeetCode

#### 问题

- 14题, 为何返回一个数组而不是指针时结果不对呢
- 14题寻找最长公共前缀
  - 优化做法
- 8题
  - 不利用long long投机取巧, 如何实现
- 36题 数独
  - 如何优化
- **205题 模式匹配?**
  - 暴力会超时
  - **学习map的使用**
  - \0的ASCII码为0

```c
// 自己的暴力方法  
// 此代码在后两个测试点会TLE
bool isIsomorphic(char* s, char* t) {
    #define MAX 256
    if (strlen(s) != strlen(t)) return false;
    int num[MAX] = {0};             // 记录每个字符分别是第几个新出现的字符
    int vis[MAX] = {0};
    // 用数组记录字符的出现规律
    int *patternS = (int *)calloc(strlen(s) + 1, sizeof(int));
    int *patternT = (int *)calloc(strlen(t) + 1, sizeof(int));
    int k = 0, l = 0;
    for (int i = 0; s[i]; i++) {
        // 是否为新出现的字符
        if (!vis[s[i]]) {
            vis[s[i]] = 1;
            num[s[i]] = ++k;
            patternS[i] = num[s[i]];
        } else patternS[i] = num[s[i]];
    }
    memset(vis, 0, sizeof(vis));
    for (int i = 0; t[i]; i++) {
        if (!vis[t[i]]) {
            vis[t[i]] = 1;
            num[t[i]] = ++l;
            patternT[i] = num[t[i]];
        } else patternT[i] = num[t[i]];
    }   
    bool flag = true;
    for (int i = 0; i < strlen(s) && flag; i++) {
        if (patternS[i] == patternT[i]) continue;
        flag = false;
    }
    return flag;
}
```

- **290题**
  - strtok分割字符串

```c
	// strtok第一次调用参数为string
	// 之后调用时,参数为NULL
	token = strtok( string, seps ); 
	while(token !=NULL)
	{
         printf("%s\n",token);
		 token=strtok(NULL,seps);
	}
```

