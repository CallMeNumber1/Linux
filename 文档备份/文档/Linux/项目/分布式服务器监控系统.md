#### 网络通信

- Client端与Server端(运输层层面)
  - 根据实际的业务不同,角色可能互换,灵活看待

- 三次握手
  - 由client端发起, server端处于listen状态
    - server端处理listen之前要做的事
    - socket()创建套接字
    - bind()绑定一个特定的IP地址(非对方的),本机上网卡的的地址
      - 一般绑定为0.0.0.0 即所有来的请求都收
    - listen()将主动变为被动,只能等待别人连接
      - 整型参数代表允许同一时刻的最大连接数
  - client进行连接
    - socket()创建套接字
    - 不需要绑定,但可以绑定,端口随机由os生成
    - 进行connect(),将结构体传入
      - 第一次握手
      - 实际上三次握手都在这个函数完成
  - server调用accept()来接受请求,返回一个新的套接字sfd,里面包含着连接信息
  - client,server都可进行send/recv进行收发信息
  - client调用close()关闭连接
- TCP套接字建立的连接是全双工,双方都可进行收发且互不影响

- 三次握手
  - SYN
  - SYNACK
  - ACK+data

- 四次挥手
  - FIN
  - ACK
  - FIN
  - 发送ACK后等待30s,确认对方收到了ACK
    - 对方如果没有收到ACK,则对方会再发送一次FIN
    - 一定要确认两边都关掉,否则会出现一方一直等待,将资源消耗殆尽的情况
    - 等待时间并不是确定的值,而是两个当时的时限

- 客户端TCP状态序列
  - 往往是

- bind()
  - bind()把用addr指定的地址赋值给用文件描述符代表的套接字sockfd。addrlen指定了以addr所指向的地址结构体的字节长度。一般来说，该操作称为“给套接字命名
  - 通常，在一个SOCK_STREAM套接字接收连接之前，必须通过bind()函数用本地地址为套接字命名
  - 调用bind()函数之后，为socket()函数创建的套接字关联一个相应地址，发送到这个地址的数据可以通过该套接字读取与使用
  - 在一般情况下，对于服务器进程问题需要调用bind()函数，对于客户进程则不需要调用bind()函数
- inet_nota(addr.sin_addr)将ＩＰ地址转换为字符串
- 







线程 10个

Master端

并发度为10(设置个全局变量)时连接10个pi

第一个线程连接pi1...

假装连一下,先简单用printf实现业务逻辑

连接,收发数据都先不写

- 写个大框架
- 输出整个流程
- 建了几个线程

- 如何开5个线程
- 10个机器怎么分配,维护,100个时怎么做



#### 成果

- 编译时 -lpthread

#### 存疑

- 互斥量和条件变量
  - pthread_mutex_t thread_mutex[THREAD_NUMBER];
  - pthread_cond_t thread_cond[THREAD_NUMBER];



#### 线程

- 创建线程

  - 第三个参数,函数,表示创建线程要干的事情
  - 最后一个参数,传入参数
  - 创建线程后,线程的执行是不可控的

  - 可以用一个结构体存当前线程的信息,或使用互斥量/互斥锁



queue[INS+1]存的是每个链表的长度

- join
  - 等待线程结束，起到一个资源回收作用
  - 不需要返回结果时第二个参数为NULL

#### 进程

- 共享内存
  - 链表放里面



Master负责收集主机信息

- 笨方法：写在配置文件，依次遍历，不采用

- clietn去连接master,主线程
- 有一个监听状态的套接字
  - 连接信息从文件中读入

- 每个线程对应一个链表
  - 线程对应的链表相当于线程的工作队列

- 传入的para参数的作用（仅用来标记是哪个线程？）
  - para里字符串的作用？？



11.20周四

#### 问题

- 线程应该何时创建
  - 创建后是否需要传入某些结构用来标识线程
  - 线程执行的任务的写法
    - 一直循环输出所要处理的client??
    - 还是将accpet写在任务中??
- 当新的client进来时如何处理
  - 在主线程插入??
    - 插入后实现master与其的通信?
    - 在线程内实现?
    - 通信时如何知道该client的sockfd
  - 重复时删除??
- 链表的结构体是否应封装一个sockfd,用来实现与client通信?
- 心跳机制??
  - 让master知道client还活着
- 客户端取连接的同时如何让服务端连接
  - select是什么??



目前思路:

- 先创建5个线程,线程内死循环输出对应链表上的client的连接
- 主线程内建立listen状态的套接字,每有一个client连接,accept创建新的连接套接字,则插入当前连接数最少的链表
- 主线程join等待子线程执行完毕



子线程的回调函数是死循环

主线程的listen也是死循环,因此下面下的join和return不可能运行



select??

#### 心跳机制

- 双机系统

- 多种机制
  - 定时
    - 每10分钟向m发送一次请求
  - 连一下什么都不干,然后断开



master监听8080端口

client监听8000端口

可以绑定同一个端口,只要不是同一台机器

目前已完成:

`master.c` `c.c`





问题

- 连接如何判断删除
  - 已完成部分删除需等待较长时间

`2018.12.11`

- 上传日志
- 把日志发过来,保存到本地
- 另外有一个处于listen状态的套接字,接受报警信息

- 删除的时候更新队列长度,中间不能有任何操作(保证原子性), 可加锁
- 除了master端,还有两个独立线程(其中一个可作为子线程的功能)
  - 一个监听心跳
  - 一个处理报警信息
  - 传文件时注意谁建立监听(根据自己的业务逻辑)
  - 存的时候以IP地址或主机为目录
    - cpu, 磁盘, 内存

问题

- client向master发送日志文件时,要建立一条短连接
  - master端想要什么数据client 端给它发什么数据
  - 由master端控制
  - 想什么时候发由你自己来决定
  - 发数据时处于另外的业务逻辑,在不同的端口监听
    - 是否需要新建一个线程用于处理数据收发??



popen是在子进程里面跑