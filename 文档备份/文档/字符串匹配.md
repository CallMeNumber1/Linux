## 字符串匹配算法

- 母串, 模板串

#### 暴力匹配算法

- 逐位匹配,时间复杂度O(m*n)
- 优化手段

  - 可以根据模式串的信息去加速匹配的过程

- 例子:

  ![2018-12-30 14-51-04屏幕截图](/home/chongh/图片/2018-12-30 14-51-04屏幕截图.png)

  当模式串匹配到第6位失配时,模式串可以直接向后跳动三位重新对齐匹配,且前两位一定匹配成功;并且有3+2=5(6-1).

  	

#### KMP算法

- **母串的指针是不会往回跳的**
  - 模式串的信息导出的两个值为n-1, n为失配的位置
  - 因为相加为n-1,因此母串的指针是不动的或者向后动的
  - 节省了大量匹配操作

![2019-01-02 16-11-25屏幕截图](/home/chongh/图片/2019-01-02 16-11-25屏幕截图.png)

- next数组:以当前作为末尾公共子串的长度
  - 以此字符作为末尾, 可以一直匹配到模式串的哪一个字符
  - 每个位置都可以记录一个信息, 指导模式串的指针如何跳
  - 当失配后,模式串指针跳到第几位去和母串指针进行匹配,找到两个指针重新对齐的位置
  - 如果谁都匹配不上,记为-1
  - 顺着第n位前面去找到Tb这种结构,使得Tb尽可能长的与Ta进行匹配

 next数组在调整模式串的指针, 母串的指针不动或向后

- next数组的生成过程
  - 是一个递归过程,是模式串的自我匹配过程
  - 把模式串拷贝出来一份

- 例如:

  ![2018-12-30 15-47-22屏幕截图](/home/chongh/图片/2018-12-30 15-47-22屏幕截图.png)

  - e和d不匹配,则去找d的前一位的next值,与next值+1的位置比较 若还不匹配,继续找,直到匹配.

- 需要理解的关键

  从暴力算法到KMP中间有个聪明的做法

  其中两个数字,向后跳多少位,以及已有多少位对齐,以及相加为n-1

  再去理解为何母串指针不动

  再看模式串的指针应该跳到哪个位置

  next数组在调整模式串的指针

- 理解
  - T为模式串，$T_0^i$代表模式串从0到i的子串
    - next[i]表示的是子串$T_0^i$中存在最长相等的前缀$T_0^{next[i]}$和后缀$T_{i-next[i]}^i$
  - next数组记录的是当前子串最长相等的前缀和后缀，为了方便，记录其中最后一个字符的下标，（前缀和后缀不包括子串自身）
  - 如果不存在相同的前缀和后缀，则`next[i]=-1`

#### SUNDAY算法

- 最快复杂度为(m/n)
  - 即每次失配都往后跳模式串的长度个数
- 找失配的字符最后一次在模式串出现的位置,之后对齐
  - 因此不会错过正确答案(反证法可证明)
- 黄金对齐点(标注的不是母串和模式串的指针)
  - 相关字符出现在第几位,母串指针往后跳几位

#### SHIFT-AND算法

- 时间复杂度O(n)
- **d数组**
  - **二进制是倒着写的**(低位在前)
  - 如何判断一个字符在第n位是否出现过
  - 1左移n位,和此数与运算,对应位置为1则出现过
    - 位运算基操
- **在母串匹配过程中,两个公式**
  - 记录一个状态P
  - 母串进来一个字符, 就计算一下得到一个新的值
  - 如果P这个数字的第n位为1, 说明整个模式串在母串中找到了匹配的位置
  - P的相应位置为n,代表以此字符为结尾可以匹配模式串的前n位

```cpp
公式里面都是整型值
母串S
P = (P << 1 | 1) & d[s[i]]
P & (1 << (n - 1)) ?= 1
```

- 以新进来的字符作为结尾,能够匹配模式串前三位的前提
  - 前一个状态匹配两位
  - 当前字符必须在模式串第三位上出现过
- 第一个公式:
  - &运算前表示有可能匹配多少字符,做完&运算才表示一定能匹配多少个
- 第二个公式
  - 代表匹没匹配成功
- P记录了多种状态,多种状态是同时往下推的
- NFA:非确定性有限状态自动机

一个模式串一旦整理成状态码,就和原来的模式串没有任何关系了

之后匹配过程中就是二进制运算左移或与了

- 正则匹配
  - 整理状态码的时候,每一个位置(列)可以有多个字符

#### 时间复杂度对比

![2019-01-02 20-31-57屏幕截图](/home/chongh/图片/2019-01-02 20-31-57屏幕截图.png)

#### 单调栈

- 维护最近偏序关系
- 单调递增栈(维护左边第一个比它小的)
  - 当要压栈时, 把所有比它大的元素弹出

- 例题:找出能切出的最大矩形

![2018-12-30 17-29-18屏幕截图](/home/chongh/图片/2018-12-30 17-29-18屏幕截图.png)

```c
思路
```

- 矩形
  - 对于i,j,先求出向下的白色格子数
  - dp值以它作为左上角点能形成的合法矩阵的数目





读新闻

业界论文,前瞻性

锻炼思维方式

知道所学的职业哪里是有价值的,才能让自己的职业有价值

语言本身价值一定,重要的是语言的使用方式



快速傅里叶变换

- 求两个多项式相乘的每个系数
  - O(n)的复杂度解决
  - 即将一个二维矩阵乘以一维矩阵的时间复杂度变为O(n)！！！

#### 字典树Trie

![2019-01-03 09-46-02屏幕截图](/home/chongh/图片/2019-01-03 09-46-02屏幕截图.png)

- 节点是集合,边是关系
- 红色节点代表此集合中有以此前缀为单词的词,即此节点中有元素独立成词
- 基本性质
  - 根节点是全集
  - **每条边代表一个字母**
  - 从根节点到某一节点上.路径上经过的字符连接起来,就是该节点对应的字符串
  - 红点是独立成词
- 排序
  - 时间复杂度可以是O(n)的,n是单词中包含字符的总数量
  - 将这些单词插入字典树中, 按顺序访问出来, 就已经排好序了
  - 也可用于整数排序
    - 但要先将整数长度补齐(因为若按字典序,9大于100)
- 结构定义
  - 节点中存储的值
  - 可以指向多少个孩子, 即边集(next[]数组)
- 结构操作
  - 插入
  - 查找
- 作用:单词查找,字符串排序

- 常用于字符串的快速检索，字符串的快速排序与去重，文本的词频统计、**计算一个字符串有多少个子串**(如何考虑)

```cpp
计蒜客：Trie树的复习
计算一个字符串有多少个不相同的子串
将字符串str从0到len的子串依次插入字典树，之后统计字典树中含有单词的节点数目（即减去根节点）
是否正确？？？
```



#### 双数组字典树

用两个数组实现字典树

父节点记录一个base，代表自己孩子的窝

子节点记录一个父节点的坐标

而flag值标记独立成词可以用负数来记录

因此base数组中0号是不用的，因为无法使用负值来记录flag

每个节点base值的确定都是独立的，**base数组存的是值，此值+数代表地址**

base值的确定

	带上三个儿子 +0 +1 +5
	
	找到一个base值使得这三个位置都为空即可
	
	如果冲突了，就换一个base值

一旦一个节点base值确定，之后就不会变了，后面冲突的自行调整

- 使用理由
  - 工程上会大量节省存储空间
  - 可以将双数组字典树直接拿给别人使用（打到文件里）

例如：根节点为1号节点，选择base值为2， 则地址[2 + 0 = 2]放a节点,check[2]=-1(a独立成词);地址[2+2 = 4]放c, check[4]=-1(c)独立成词; 地址[2 + 5 = 7]放f，check[7] = 1.

接着再往下确定子节点中含有子节点的base值:base[2] base[4] base[7]



尝试

- 将字典直接转化为双数组字典树 	

## AC自动机

多模匹配：多个模式串

字典树的多模匹配类似于单模匹配的暴力匹配，因此可进行优化一些没有必要的运算

	每次匹配失败时文本串指针向后一位，字典树的指针重新回到根节点

即字典树+KMP的思想

不再是传统的树型结构了

文本串指针不会回溯，相当于一台小电脑，适合流式处理，每进来一个字符，跳转一个状态

失败指针（等价匹配指针）匹配成功我等于匹配成功你

树中第二层节点的失败指针很好建立，再建立第二层、第三层逐层建立，因此要采用队列。

- 因此用广度优先搜索的方法构造失败指针
  - 每个节点都有一个失败指针，首先将根节点的失败指针置空，根节点的直接子节点的失败指针指向根节点。
  - 对Trie树广度优先搜索，每个节点的失败指针都是由它父节点的失败指针决定的
- 层序遍历用队列，深度遍历用栈

2019.1.20

- 考虑建立失败指针的过程，有无可能使用深度遍历的方式建立？
- 先建立父节点的失败指针，之后建立子节点的失败指针。如果遇到子节点的父节点失败指针还未建立，则递归向上去建立父节点的失败指针

#### AC自动机优化-线索化

用next数组取代了fail指针的作用

节点的next数组空的位置可以利用起来

线索化后next不一定存子节点了，存的是下一跳应该跳到哪里

好处：下个状态应该跳到哪个节点，此状态转移是O(1)的

关于如何clean的问题，可以弄个数组存每个节点的地址，之后再clean

	因为是图的结构，不能按照树去clean了
	
	另一种思路，fail指针构成了一棵树，统计入度出度，删除入度为0的节点

#### 双数组字典树转化成AC自动机

数据结构学习的是思想

而会了一种实现后，另一种实现相当于翻译这种实现

双数组字典树也可以线索化，利用中间零星的空间，但仍不能实现一步跳转

#### 关于中文字典树的思考

	中文占3个字符（UTF-8），24位，最大到100多万
	
	我们存字典树时，是把字符映射后的数字存进去的。中间做了一步重要的转换：

即字符串映射成数字串，再存到字典树

#### 二叉字典树+哈弗曼编码

存二进制的01串

但会造成层数过深，因此可使用哈弗曼编码重新编码，可最大程度节省空间

工业界使用的大部分为二叉字典树，内存大的可使用64叉字典树

## 任务

1. 周三之前，将双数组字典树构建过程改成递归版



2. 周三之前交一份二叉字典树的代码
3. 周三之前交一份带哈弗曼编码的二叉字典树

较难实现的：二叉字典树AC自动机

#### 思路扩展

- AC自动机可以解决多模匹配问题，因此任何序列包括数字序列都可以看成字符串
- 例如：在连续的数字序列中，找出k位，使得排序完是连续的
  - 

#### 计蒜客 疑似病毒问题

- AC自动机+可达矩阵（矩阵快速幂）+动态规划（递推）
- 复制两份AC自动机，得到一个大型的图，走n步到达第三个自动机即为至少匹配两个串的情况
- 可达矩阵m，m^2代表两步可达的方法总数，m^n代表n步可达的方法总数
- 考察对AC自动机本质的理解，本质是个图

#### 思考题目

1. 

   找到最浅的不满26个英文字母的层即可

2. 单词集合s，能不能找到长度为n的字符串不包含任何s中的单词

   AC自动机，从根节点找到一条长度为n的路径，不经过任何红色节点（即不经过独立成词的节点），即最后可达矩阵中不全为0

因此一定要意识到**AC自动机本质上是个图**，所有在图上的花招都可以使用，图上最常用的花招就是可达矩阵。

字典树等价于字典，将匹配转化成从母串中找是否出现了这些单词

加了失败指针的字典树即为AC自动机

单向等价匹配

先确定父节点的失败指针

加上失败指针后，母串指针也没有回溯，母串每次进来一个字符

本身也是一个状态机

## LeetCode

#### 问题

- 14题, 为何返回一个数组而不是指针时结果不对呢
- 14题寻找最长公共前缀
  - 优化做法
- 8题
  - 不利用long long投机取巧, 如何实现
- 36题 数独
  - 如何优化
- **205题 模式匹配?**
  - 暴力会超时
  - **学习map的使用**
  - \0的ASCII码为0

```c
// 自己的暴力方法  
// 此代码在后两个测试点会TLE
bool isIsomorphic(char* s, char* t) {
    #define MAX 256
    if (strlen(s) != strlen(t)) return false;
    int num[MAX] = {0};             // 记录每个字符分别是第几个新出现的字符
    int vis[MAX] = {0};
    // 用数组记录字符的出现规律
    int *patternS = (int *)calloc(strlen(s) + 1, sizeof(int));
    int *patternT = (int *)calloc(strlen(t) + 1, sizeof(int));
    int k = 0, l = 0;
    for (int i = 0; s[i]; i++) {
        // 是否为新出现的字符
        if (!vis[s[i]]) {
            vis[s[i]] = 1;
            num[s[i]] = ++k;
            patternS[i] = num[s[i]];
        } else patternS[i] = num[s[i]];
    }
    memset(vis, 0, sizeof(vis));
    for (int i = 0; t[i]; i++) {
        if (!vis[t[i]]) {
            vis[t[i]] = 1;
            num[t[i]] = ++l;
            patternT[i] = num[t[i]];
        } else patternT[i] = num[t[i]];
    }   
    bool flag = true;
    for (int i = 0; i < strlen(s) && flag; i++) {
        if (patternS[i] == patternT[i]) continue;
        flag = false;
    }
    return flag;
}
```

- **290题**
  - strtok分割字符串

```c
	// strtok第一次调用参数为string
	// 之后调用时,参数为NULL
	token = strtok( string, seps ); 
	while(token !=NULL)
	{
         printf("%s\n",token);
		 token=strtok(NULL,seps);
	}
```

#### C++ string转化为char *

- `const char *p = str.c_str();`
- istringstream

```cpp
istringstream::istringstream(string str);
它的作用是从string对象str中读取字符
#include<iostream>  
#include<sstream>        //istringstream 必须包含这个头文件
#include<string>  
using namespace std;  
int main()  
{  
    string str="i an a boy";  
    istringstream is(str);  
    string s;  
    while(is>>s)  
    {  
        cout<<s<<endl;  
    }  
      
} 
输出是:
i
am
a
boy
```

## STL-vector

- 创建
  - `vector<string> v(26, "")`

## STL-map

#### 简介

- Map是STL的一个关联容器，它提供一对一的数据处理能力.（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）

- map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的

- map是一类关联式容器。它的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。对于迭代器来说，可以修改实值，而不能修改key

#### 功能

- 自动建立Key － value的对应， key 和 value可以是任意你需要的类型
- 根据key值快速查找记录，查找的复杂度基本是Log(N)

#### 使用

- 构造与插入

```cpp
#include <map>
std:map<int, string> mapStudent
// 插入
mapStudent.insert(pair<int, string>(1, "student_one"));  //insert插入pair数据
mapStudent.insert(map<int, string>::value_type(1, "student_one")); //insert插入value_type数据
mapStudent[1] = "student_three";						//用数组方式插入数据
```

- 以上三种用法区别：
  - insert函数插入的数据，在数据的插入上涉及到集合的唯一性这个概念，当map中有这个关键字时，insert操作无法插入。
  - 数组方式可以覆盖以前关键字对应的值

- map大小：`int size = mapStudent.size()`

- 数据的遍历

```cpp
// 利用前向迭代器
map<int, string>::iterator iter;  
for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)
	cout << iter->first << " " << iter->second <<endl;
// 利用反向迭代器
map<int, string>::reverse_iterator iter;
for (iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++)
    cout << iter->first << " " << iter->second << endl;
// 用数组的方式 疑问：：当key不是整型时是否还能进行
int size = mapStudent.size();
for (int index = 1; index <= size; index++)
    cout << mapStudent[index] << endl;
```

注意：用数组遍历时，下标从1开始，**疑问：：当key不是整型时是否还能进行**

- 查找（包括判定这个关键字是否在map中出现）

````cpp
// 1、用count函数判定关键字是否出现，缺点是无法定位数据出现位置，返回0或1
// 2、用find函数定位，返回一个迭代器，当数据出现时返回所在位置的迭代器，否则返回的迭代器等于end函数的
map<int, string>::iterator iter;
iter = mapStudent.find(1);
if (iter != mapStudent.end()) 
    cout << "Find, the value is	" << iter->second << endl;
````

通过map对象的方法获取的`iterator`对象是一个`std::pair`对象，包括两个数据`iterator->first`,`iterator->second`分别代表关键字和存储的数据

- 删除

```cpp
iterator erase（iterator it);//通过一个条目对象删除
iterator erase（iterator first，iterator last）//删除一个范围
size_type erase(const Key&key);//通过关键字删除
clear()就相当于enumMap.erase(enumMap.begin(),enumMap.end());
```

**范围删除要注意，删除区间是一个前闭后开的集合，是STL的特性。**

- 排序问题
  - map中的元素自动按Key升序排序，因此不能使用sort函数

## 计算字符串的最长回文子串

1. 暴力枚举字符串的每一个子串，并判断这个子串是否为回文串`O(n3)`
2. 枚举回文串的中点，要分两种情况：一种是回文串长度为奇数，另一种是回文串长度为偶数的情况`O(n2)`
3. 马拉车算法`O(n)`

#### 马拉车算法(Manacher‘s Algorithm)

用来求解一个字符串的最长回文子串问题，算法复杂度降到了线性

1. 算法过程分析

由于回文串分为奇回文(bab)和偶回文(bccb)，而在处理奇偶问题上比较繁琐，因此我们在字符串首尾，及各字符间插入一个字符（这个字符未在串里出现过）,比如`#`

例如:`s="abba" s_new="$#a#b#b#a#"`，（字符`$`是为了防止越界，见代码）

这样一来，**长度都转换成了奇数**

![1547711156829](/tmp/1547711156829.png)

定义一个辅助数组`int p[]`，**其中`p[i]`代表以`i`为中心的最长回文的半径**，可以证明`p[i]-1`正好是对应回文串的长度。

```
证明如下：
首先在转换得到的字符串T中，所有的回文字串的长度都为奇数，那么对于以T[i]为中心的最长回文字串，其长度就为2*Len[i]-1,经过观察可知，T中所有的回文子串，其中分隔符的数量一定比其他字符的数量多1，也就是有Len[i]个分隔符，剩下Len[i]-1个字符来自原字符串，所以该回文串在原字符串中的长度就为Len[i]-1。
```

有了这个性质，原问题就转化为求所有的p[i]，找到最大值，`max(p[i]) - 1`即为答案

**最长子串的长度是半径减1，起始位置是中间位置减去半径再除以2**

2. 求解p数组

![1547711258752](/tmp/1547711258752.png)

设置两个变量, `mx` `id`，mx代表以id为中心的最长回文的右边界，即`mx=id+p[id]`

假设我们现在要求p[i], 即以i为中心的最长回文半径。

因为是从左往右依次计算p[i]，当计算p[i]时，`p[j](0<=j<i)`已经计算完毕, mx为之前计算中最长回文子串右端点的最大值，id为取得这个最大值回文串的中心位置

- 如果`i<mx`，如上图,则

```cpp
if (i < mx) p[i] = min(p[2 * id - i], mx - i);
```

	p[2 * id - i]即p[j]，是i关于id的对称点，因此我们可以利用p[j]来加速查找

- 如果`i>=mx`，说明对于中点为i的回文串还一点都没有匹配，这个时候，就只能老老实实的一个一个匹配，匹配完成后要更新mx的位置和对应的id以及p[i]

3. 代码实现

```cpp
见github:Homework/data_structure/9.string/manacher.cpp
```

4. 时间复杂度分析

因为算法只有遇到还没有匹配的位置时才进行匹配，已经匹配过的位置不再进行匹配，所以对于T字符串中的每一个位置，只进行一次匹配，所以Manacher算法的总体时间复杂度为O(n)，其中n为T字符串的长度，由于T的长度事实上是S的两倍，所以时间复杂度依然是线性的。





两数之和

- 哈希表
- 排序后用二维数组 杨氏矩阵

第一个没有出现的正数 2.cpp

## leetcode

3

378

	查找排名 O(m + n)
	
	总的复杂度 O(m + n) * logk

**8 atoi**

13 roman

**28**

	memset按字节设置值，因此只可以设置0和-1，其他数值都不行
	
	Sunday算法

**36**

	ind 宫格坐标
	
	46 - 48 = -2 （`.` -`'0'` ）
	
	用二进制位标记

**58**

	太优雅

125

	双指针，中间最多有个过滤的操作

205

	开两个 互相映射

290

	哈希表做映射即可

- calloc分配内存的时候，两个参数前后位置无所谓？
- calloc分配的内存，里面的指针指向NULL，整型为0



## 船长寄语

逻辑最重要

其次是知识储量

面试考的是主观题的部分，因此在面对不会的题目，是展示自己逻辑思维的时候

小公司招成手，大公司招新手

因此会招基础扎实的，学习能力强，团队协作能力强

有价值的东西是算法和数据结构是其中的思想

学习算法是在进行思维逻辑上的过度



要面试的话提前准备简历，将必要而没那么重要的事情先做了



## 刷题收获

#### 字典树

- 统计一个字符串不相同的子串个数

#### AC自动机

- 建立AC自动机时，要设置一个队列，因此统计字典树的节点数量，可以节省队列空间。统计方法：节点中增加一个count变量，字典树每插入一个字符，让`root->count++`，即可统计出除根节点以外的节点数目
- 查询每个单词在文本中出现的次数
  - 在insert函数中，返回指向当前单词数的指针`&p->count`，在主函数用一组指针变量接受`ans[i] = insert(root, pattrern[i])`，即`ans[i]`和单词的`count`指向同一块内存；当进行文本的match时，如果出现了此单词，就让单词对应的数量加1`p->count++`，`ans[i]`随之改变，最后输出`ans[i]`即可

- 在字典树的节点中，可以根据需要增加一个字符串变量`char *str`或一个用来计数的变量`count`
  - str的赋值在insert函数调用最后`p->str = strdup(str)`

## 字符串旋转矩阵解法

计蒜客字符串的终极大题

思路：先还原出原本的字符串，然后使用朴素的AC自动机去匹配即可

还原过程： 先写出最后一列的字符，再写出排序后的字符，见下图

可推出如下结论：排序后，相同的字符，在循环左移后，相对位置不变

![1548058593896](/tmp/1548058593896.png)

## 疑问

1. 计蒜客：Trie树的复习
   计算一个字符串有多少个不相同的子串
   将字符串str从0到len的子串依次插入字典树，之后统计字典树中含有单词的节点数目（即减去根节点）
   是否正确？？？

2. 计蒜客：AC自动机的复习

   为何插入一个单词时，`p->flag += 1`，而不是置1呢？

   （船长的示范代码中是置1）

![1547605606836](/tmp/1547605606836.png)