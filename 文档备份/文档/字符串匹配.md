## 字符串匹配算法

- 母串, 模板串

#### 暴力匹配算法

- 逐位匹配,时间复杂度O(m*n)
- 优化手段

  - 可以根据模式串的信息去加速匹配的过程

- 例子:

  ![2018-12-30 14-51-04屏幕截图](/home/chongh/图片/2018-12-30 14-51-04屏幕截图.png)

  当模式串匹配到第6位失配时,模式串可以直接向后跳动三位重新对齐匹配,且前两位一定匹配成功;并且有3+2=5(6-1).

  	

#### KMP算法

- **母串的指针是不会往回跳的**
  - 模式串的信息导出的两个值为n-1, n为失配的位置
  - 因为相加为n-1,因此母串的指针是不动的或者向后动的
  - 节省了大量匹配操作

![2019-01-02 16-11-25屏幕截图](/home/chongh/图片/2019-01-02 16-11-25屏幕截图.png)

- next数组:以当前作为末尾公共子串的长度
  - 以此字符作为末尾, 可以一直匹配到模式串的哪一个字符
  - 每个位置都可以记录一个信息, 指导模式串的指针如何跳
  - 当失配后,模式串指针跳到第几位去和母串指针进行匹配,找到两个指针重新对齐的位置
  - 如果谁都匹配不上,记为-1
  - 顺着第n位前面去找到Tb这种结构,使得Tb尽可能长的与Ta进行匹配

 next数组在调整模式串的指针, 母串的指针不动或向后

- next数组的生成过程
  - 是一个递归过程,是模式串的自我匹配过程
  - 把模式串拷贝出来一份

- 例如:

  ![2018-12-30 15-47-22屏幕截图](/home/chongh/图片/2018-12-30 15-47-22屏幕截图.png)

  - e和d不匹配,则去找d的前一位的next值,与next值+1的位置比较 若还不匹配,继续找,直到匹配.

- 需要理解的关键

  从暴力算法到KMP中间有个聪明的做法

  其中两个数字,向后跳多少位,以及已有多少位对齐,以及相加为n-1

  再去理解为何母串指针不动

  再看模式串的指针应该跳到哪个位置

  next数组在调整模式串的指针

#### SUNDAY算法

- 最快复杂度为(m/n)
  - 即每次失配都往后跳模式串的长度个数
- 找失配的字符最后一次在模式串出现的位置,之后对齐
  - 因此不会错过正确答案(反证法可证明)
- 黄金对齐点(标注的不是母串和模式串的指针)
  - 相关字符出现在第几位,母串指针往后跳几位

#### SHIFT-AND算法

- 时间复杂度O(n)
- **d数组**
  - **二进制是倒着写的**(低位在前)
  - 如何判断一个字符在第n位是否出现过
  - 1左移n位,和此数与运算,对应位置为1则出现过
    - 位运算基操
- **在母串匹配过程中,两个公式**
  - 记录一个状态P
  - 母串进来一个字符, 就计算一下得到一个新的值
  - 如果P这个数字的第n位为1, 说明整个模式串在母串中找到了匹配的位置
  - P的相应位置为n,代表以此字符为结尾可以匹配模式串的前n位

```cpp
公式里面都是整型值
母串S
P = (P << 1 | 1) & d[s[i]]
P & (1 << (n - 1)) ?= 1
```

- 以新进来的字符作为结尾,能够匹配模式串前三位的前提
  - 前一个状态匹配两位
  - 当前字符必须在模式串第三位上出现过
- 第一个公式:
  - &运算前表示有可能匹配多少字符,做完&运算才表示一定能匹配多少个
- 第二个公式
  - 代表匹没匹配成功
- P记录了多种状态,多种状态是同时往下推的
- NFA:非确定性有限状态自动机

一个模式串一旦整理成状态码,就和原来的模式串没有任何关系了

之后匹配过程中就是二进制运算左移或与了

- 正则匹配
  - 整理状态码的时候,每一个位置(列)可以有多个字符

#### 时间复杂度对比

![2019-01-02 20-31-57屏幕截图](/home/chongh/图片/2019-01-02 20-31-57屏幕截图.png)

#### 单调栈

- 维护最近偏序关系
- 单调递增栈(维护左边第一个比它小的)
  - 当要压栈时, 把所有比它大的元素弹出

- 例题:找出能切出的最大矩形

![2018-12-30 17-29-18屏幕截图](/home/chongh/图片/2018-12-30 17-29-18屏幕截图.png)

```c
思路
```

- 矩形
  - 对于i,j,先求出向下的白色格子数
  - dp值以它作为左上角点能形成的合法矩阵的数目





读新闻

业界论文,前瞻性

锻炼思维方式

知道所学的职业哪里是有价值的,才能让自己的职业有价值

语言本身价值一定,重要的是语言的使用方式



快速傅里叶变换

- 求两个多项式相乘的每个系数
  - O(n)的复杂度解决
  - 即将一个二维矩阵乘以一维矩阵的时间复杂度变为O(n)！！！

#### 字典树Trie

![2019-01-03 09-46-02屏幕截图](/home/chongh/图片/2019-01-03 09-46-02屏幕截图.png)

- 节点是集合,边是关系
- 红色节点代表此集合中有以此前缀为单词的词,即此节点中有元素独立成词

- 基本性质
  - 根节点是全集
  - **每条边代表一个字母**
  - 从根节点到某一节点上.路径上经过的字符连接起来,就是该节点对应的字符串
  - 红点是独立成词
- 排序
  - 时间复杂度可以是O(n)的,n是单词中包含字符的总数量
  - 将这些单词插入字典树中, 按顺序访问出来, 就已经排好序了
  - 也可用于整数排序
    - 但要先将整数长度补齐(因为若按字典序,9大于100)
- 结构定义
  - 节点中存储的值
  - 可以指向多少个孩子, 即边集(next[]数组)
- 结构操作
  - 插入
  - 查找
- 作用:单词查找,字符串排序

#### 双数组字典树

用两个数组实现字典树

父节点记录一个base，代表自己孩子的窝

子节点记录一个父节点的坐标

而flag值标记独立成词可以用负数来记录

因此base数组中0号是不用的，因为无法使用负值来记录flag

每个节点base值的确定都是独立的，**base数组存的是值，此值+数代表地址**

base值的确定

	带上三个儿子 +0 +1 +5

	找到一个base值使得这三个位置都为空即可

	如果冲突了，就换一个base值

一旦一个节点base值确定，之后就不会变了，后面冲突的自行调整

- 使用理由
  - 工程上会大量节省存储空间
  - 可以将双数组字典树直接拿给别人使用（打到文件里）

例如：根节点为1号节点，选择base值为2， 则地址[2 + 0 = 2]放a节点,check[2]=-1(a独立成词);地址[2+2 = 4]放c, check[4]=-1(c)独立成词; 地址[2 + 5 = 7]放f，check[7] = 1.

接着再往下确定子节点中含有子节点的base值:base[2] base[4] base[7]



尝试

- 将字典直接转化为双数组字典树 	

## LeetCode

#### 问题

- 14题, 为何返回一个数组而不是指针时结果不对呢
- 14题寻找最长公共前缀
  - 优化做法
- 8题
  - 不利用long long投机取巧, 如何实现
- 36题 数独
  - 如何优化
- **205题 模式匹配?**
  - 暴力会超时
  - **学习map的使用**
  - \0的ASCII码为0

```c
// 自己的暴力方法  
// 此代码在后两个测试点会TLE
bool isIsomorphic(char* s, char* t) {
    #define MAX 256
    if (strlen(s) != strlen(t)) return false;
    int num[MAX] = {0};             // 记录每个字符分别是第几个新出现的字符
    int vis[MAX] = {0};
    // 用数组记录字符的出现规律
    int *patternS = (int *)calloc(strlen(s) + 1, sizeof(int));
    int *patternT = (int *)calloc(strlen(t) + 1, sizeof(int));
    int k = 0, l = 0;
    for (int i = 0; s[i]; i++) {
        // 是否为新出现的字符
        if (!vis[s[i]]) {
            vis[s[i]] = 1;
            num[s[i]] = ++k;
            patternS[i] = num[s[i]];
        } else patternS[i] = num[s[i]];
    }
    memset(vis, 0, sizeof(vis));
    for (int i = 0; t[i]; i++) {
        if (!vis[t[i]]) {
            vis[t[i]] = 1;
            num[t[i]] = ++l;
            patternT[i] = num[t[i]];
        } else patternT[i] = num[t[i]];
    }   
    bool flag = true;
    for (int i = 0; i < strlen(s) && flag; i++) {
        if (patternS[i] == patternT[i]) continue;
        flag = false;
    }
    return flag;
}
```

- **290题**
  - strtok分割字符串

```c
	// strtok第一次调用参数为string
	// 之后调用时,参数为NULL
	token = strtok( string, seps ); 
	while(token !=NULL)
	{
         printf("%s\n",token);
		 token=strtok(NULL,seps);
	}
```

#### C++ string转化为char *

- `const char *p = str.c_str();`
- istringstream

```cpp
istringstream::istringstream(string str);
它的作用是从string对象str中读取字符
#include<iostream>  
#include<sstream>        //istringstream 必须包含这个头文件
#include<string>  
using namespace std;  
int main()  
{  
    string str="i an a boy";  
    istringstream is(str);  
    string s;  
    while(is>>s)  
    {  
        cout<<s<<endl;  
    }  
      
} 
输出是:
i
am
a
boy
```

## STL-vector

- 创建
  - `vector<string> v(26, "")`

## STL-map

#### 简介

- Map是STL的一个关联容器，它提供一对一的数据处理能力.（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）

- map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的

- map是一类关联式容器。它的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。对于迭代器来说，可以修改实值，而不能修改key

#### 功能

- 自动建立Key － value的对应， key 和 value可以是任意你需要的类型
- 根据key值快速查找记录，查找的复杂度基本是Log(N)

#### 使用

- 构造与插入

```cpp
#include <map>
std:map<int, string> mapStudent
// 插入
mapStudent.insert(pair<int, string>(1, "student_one"));  //insert插入pair数据
mapStudent.insert(map<int, string>::value_type(1, "student_one")); //insert插入value_type数据
mapStudent[1] = "student_three";						//用数组方式插入数据
```

- 以上三种用法区别：
  - insert函数插入的数据，在数据的插入上涉及到集合的唯一性这个概念，当map中有这个关键字时，insert操作无法插入。
  - 数组方式可以覆盖以前关键字对应的值

- map大小：`int size = mapStudent.size()`

- 数据的遍历

```cpp
// 利用前向迭代器
map<int, string>::iterator iter;  
for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)
	cout << iter->first << " " << iter->second <<endl;
// 利用反向迭代器
map<int, string>::reverse_iterator iter;
for (iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++)
    cout << iter->first << " " << iter->second << endl;
// 用数组的方式 疑问：：当key不是整型时是否还能进行
int size = mapStudent.size();
for (int index = 1; index <= size; index++)
    cout << mapStudent[index] << endl;
```

注意：用数组遍历时，下标从1开始，**疑问：：当key不是整型时是否还能进行**

- 查找（包括判定这个关键字是否在map中出现）

````cpp
// 1、用count函数判定关键字是否出现，缺点是无法定位数据出现位置，返回0或1
// 2、用find函数定位，返回一个迭代器，当数据出现时返回所在位置的迭代器，否则返回的迭代器等于end函数的
map<int, string>::iterator iter;
itet = mapStudent.find(1);
if (itet != mapStudent.end()) 
    cout << "Find, the value is	" << iter->second << endl;
````

通过map对象的方法获取的`iterator`对象是一个`std::pair`对象，包括两个数据`iterator->first`,`iterator->second`分别代表关键字和存储的数据

- 删除

```cpp
iterator erase（iterator it);//通过一个条目对象删除
iterator erase（iterator first，iterator last）//删除一个范围
size_type erase(const Key&key);//通过关键字删除
clear()就相当于enumMap.erase(enumMap.begin(),enumMap.end());
```

**范围删除要注意，删除区间是一个前闭后开的集合，是STL的特性。**

- 排序问题
  - map中的元素自动按Key升序排序，因此不能使用sort函数

