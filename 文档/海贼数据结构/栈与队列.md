## 队列

- 基本操作
  - 入队
    - 会出现假溢出现象,通过循环队列解决.
  - 出队
- 循环队列

```cpp
// STL中queue基本操作
queue<int> q;
q.push(1);
q.push(2);
while (!q.empty())) {
    cout << q.front() << endl;
    q.pop();
}
```



## 栈

- 括号匹配
  - 为什么能用栈做
- 栈的本质
  - 将思维模式提取出来,才能程式化实现.
  - 当只有一种符号时()
    - 每个位置上左括号数量等于右括号数量且左大于等于右括号,最后一个位置上左等于右括号
  - 获得的思维方式
    - +1可以等价于进,-1可以等价于出
    - 一对()可以等价为一个完整的事件
    - (())可以看做事件与事件之间的完全包含关系
    - 由括号的等价变换,得到了一个新的数据结构
  - - **可以处理具有完全包含关系的问题**
    - 递归和执行函数时都要用到栈
    - 因此个括号序列也可以等价于一个函数执行流程
    - 因此可以用括号序列表示二叉树!
- 即:一种数据结构,一组抽象的括号序列,一个程序执行流程,一个高级数据结构二叉树,都能相互联系起来.
- 表达式求值问题
  - 把表达式求值看成一个表达式树的求解,根节点是优先级最低的运算符,操作符和操作数都是树上的节点

```cpp
// STL中的stack基本操作
stack<int> s;
s.push(1);
s.push(2);
while (!s.empty()) {
    cout << s.top() << endl;
    s.pop();
}
```

## 栈与队列

用两个队列可以实现栈的操作

用两个栈可以实现队列的操作

## 单调栈

- 维护最近偏序关系
- 单调栈只能在栈底操作
- 性质：
  - 若是单调递增栈，则从栈顶到栈底的元素是严格递增的。若是单调递减栈，则从栈顶到栈底的元素是严格递减的。
  - 使用单调栈可以找到元素向左遍历第一个比他小的元素，也可以找到元素向左遍历第一个比他大的元素
- 元素进栈过程：
  - 对于单调递增栈，若当前进栈元素为e，从栈顶开始遍历元素，把小于e或者等于e的元素弹出栈，直接遇到一个大于e的元素或者栈为空为止，然后再把e压入栈中。对于单调递减栈，则每次弹出的是大于e或者等于e的元素。

#### 例题1：木桶倒水问题

- 问题描述：地上从左到右竖立着 n 块木板，从 1 到 n 依次编号，如下图所示。我们知道每块木板的高度，在第 n 块木板右侧竖立着一块高度无限大的木板，现对每块木板依次做如下的操作：对于第 i 块木板，我们从其右侧开始倒水，直到水的高度等于第 i 块木板的高度，倒入的水会淹没 ai 块木板（如果木板左右两侧水的高度大于等于木板高度即视为木板被淹没），求 n 次操作后，所有 ai 的和是多少。如图上所示，在第 4 块木板右侧倒水，可以淹没第 5 块和第 6 块一共 2 块木板，a4 = 2。

![1549714595239](/tmp/1549714595239.png)

- 解法1：暴力求解，复杂度是O(n²)。问题即寻找在第 i 个数右边第一个比它大的数。可以暴力求解，从 1 循环到 n，对每块木板再往右循环一遍，这样的时间复杂度是O(n²) 。
- 解法2：使用单调栈维护右边第一个比它大的元素
  - 思路：从左往右将木板节点压栈，遇到比栈顶木板高的木板就将当前栈顶木板出栈并计算淹没的木板数，如此循环直到栈顶木板高度比当前木板高或者栈为空，然后将此木板压栈。木板全都压栈完成后，栈内剩余的木板都是右侧没有比它们更高的木板的，所以一个个出栈并计算ai=n+1-temp_id-1(用最右边无限高的木板减)

```cpp
//从左往右解木板倒水
int main() {
    int n,ans=0;
    cin>>n;
    Stack<Node> stack(n);
    Node temp;
    for(int i=1;i<=n;i++){
        cin>>temp.height;
        temp.id=i;
        //遇到了右侧第一个比栈顶元素大的元素,计算并出栈
        while(!stack.empty()&&stack.top().height<=temp.height){
            ans=ans+i-stack.top().id-1;
            stack.pop();
        }
        stack.push(temp);
    }
    //现在栈中的木板右侧没有比它高的木板,用最右侧无限高的木板减
    while(!stack.empty()){
        ans=ans+n+1-stack.top().id-1;
        stack.pop();
    }
    cout<<ans<<endl;
    return 0;
}
```



#### 例题2：矩形

 单调栈：维护某个数字最近的比它大或比它小的数字

`f[i][j]`代表从当前位置向下数，白色格子数量

`dp[i][j]`为以此点为左上角坐标的合法子矩阵数量

找到`(i,j)`右边最近的一个点`(i,k)`,使得`f(i,k)<f(i,j)`，对于这种最小关系的维护，使用**`单调递增栈`**，整体时间复杂度O(n)，均摊时间复杂度为O(1).

即每个`dp[i][j]`的计算是O(1)的，状态数为$n^2$个，每次转移O(1)，总时间复杂度为`O(n^2)`

## 单调队列

- 维护区间最值（滑动窗口内部的最值），这个区间也可以是变长区间

- 单调递减序列：维护区间最大值

  - 比如递减的单调队列,维护区间的最大值

    入队时,从后往前挤,把小于它的都挤出去

    队首即为最大值


- 单调递增序列：维护区间最小值

一般使用的时候要封装一个结构体，存储值与位置

#### 应用举例

- 问题描述：在一个无序数组（无重复元素）中，找出连续的五个数，这5个数排序之后是连续的五个数（顺子）

- 解法一：通过分析，我们可以得出这`5`个数有一个性质，就是最大值与最小值的差是`4`。我们可以将每五个数看做一组，找出这五个数当中的最大值和最小值，若差值为`4`，则代表我们找到了，可以借助滑动窗口来实现。找五个数中的最大值和最小值，若通过普通的比较查找，则需要比较`10`次，最终解决这个问题的时间复杂度是`O(10n)`；我们可以通过单调队列来维护这五个数的最大值和最小值，利用单调递减队列维护最大值，用单调递增队列维护最小值，
  - 对于每个元素,都入队和出队一次,因此均摊时间复杂度为`O(2n)`,由于维护两个单调队列,则时间复杂度为`O(4n)`
- 解法二：连续的`5`个数（顺子）排列组合的话也只有`120`种情况，我们可以将所有的情况列举出来，计算相邻两个数的差，也只有`120`种情况，将这些情况记录下来。然后我们扫描元素的时候（`5`个为一组），只需要计算相邻元素的差，并与我们记录的情况作对比就行了。接下来要解决记录与对比的问题，我们知道上面提到的差的范围为`[-4,4]`，我们为其加上`5`，变成`[0,9]`，也就是每两个数的差可以用`0~9`之间的一个数表示，一共有`4`个差，也就是一个`4`位数就可以表示一种情况，我们只需要开一个`10000`的数组来记录就行了，这时对比的时间复杂度就是`O(1)`。这样，我们解决这个问题的时间复杂度就是`O(n)`了。
- 补充：对于解法2，如果是要找连续的`7`个数，则差的范围会变成`[-6,6]`，我们为其加上`7`，变成`[0,13]`，这时差的范围就大于`10`了，即每一位数字就大于`10`了，上述算法看似就不行了，不过别忘了我们并不是只能用十进制来表示一个数，这里我们可以用十四进制来表示每一个数，那么接下来的解法就类似了。当待求的连续的数的个数改变之后，只需换个进制来表示两个元素的差就行了。不过当待求的连续的数的个数太多时，我们就无法一一列举所有的情况了，这个算法就不适用了，就得退化到上述利用单调队列的解法，单调队列的解法是通用的。

