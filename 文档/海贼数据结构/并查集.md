## 森林与并查集

森林：多个树，独木不成林

解决：**连通性判断**问题（没有方向性的连通）

#### 连通性问题

两个操作

- 根据已知连通关系，连通两个点
- 查询某两个点是否是连通的

#### QUICK-FIND算法

连通判断非常快

- 染色法
- 连通两个点的操作就相当于染成同一颜色,把和某个点相关的都改成另一种颜色
- 颜色一样则是连通的

1. 联通判断：O(1)
2. 合并操作：O(n)

```markdown
思考：
1. quick-find算法的连通判断非常快，可是合并操作非常慢
2. 本质上问题中只是需要知道一个点与哪些点的颜色相同
3. 而若干点的颜色可以通过间接指向同一个顶点
4. 合并操作时，实际上是将一棵树作为另一棵树的子树
```

#### QUICK-UNION算法

找到两集合的代表元素，将根节点进行合并，即老大之间的合并

找到子树的根节点，做一步操作即可

1. 连通判断：树高复杂度
2. 合并操作：树高复杂度

```markdown
思考：
极端情况下会退化成一条链
将节点数量多的接到少的树上面，导致了退化
将树高深的接到浅的上面，导致了退化
```

- 按秩优化

一种直接的想法是按树高进行合并，树高的当大哥

一颗树的平均查找次数是衡量的指标

证明得到让节点数量少的成为子树

#### Weighted Quick-Union

1. 连通判断：log(N)
2. 合并操作：log(N)

根据平均查找次数和节点数进行推导

问题最终优化：**路径压缩**

- 路径压缩后时间复杂度find和merge都接近于O(1)

并查集本身是个森林



## LeetCode

#### 128 哈希表+并查集

- 本质：连通性判断问题
- 判断一个数的连通是否存在，存在则建立一条关系
  - 用哈希

- 并查集开的大小第一种考虑：和数组最大数相等，但数字太大就不行了
- 第二种考虑：和数组长度相等 O(n)

查找两大神器：哈希表，平衡二叉树

STL中map和unorderd_map一个用平衡二叉查找树（红黑树）实现，一个用哈希表实现 

学会了查找，就解决了90%以上的问题

#### 130

- 在外面再套一圈圆圈

#### 200

- 对每一个位置进行编号
- 最后判断森林有几棵树即可
  - 判断可采用的思路：每进行一次真正的连通，就将树的数量减1

单纯的学数据结构本身没有意义，真正有价值的是解题思路（数据结构的思想）

#### 547

求森林中树的个数即可

#### 684

找到第一条冗余连接即可

#### 685

如果把树看成有向图

每个点的入度为0或1，因此分两种情况讨论

1. 如果多的边指向入度为1的，则入度变为2，因此找到这个入度为2的删除即可

   要保证删掉一个边之后整个图还是连通的

2. 如果多的边指向入度为0的，即指向根节点，则树中一定有环

   先找出环上的点，可采取如下做法：找出度为0的点删除，并且将父节点的出度减1，当父节点的出度减为0时，再删除，依次进行。此过程可用队列完成，删除可使用标记来完成，没有标记的点即为环上的点。找到环上的点后，判断删除哪条边不影响连通性，就把它删除。	