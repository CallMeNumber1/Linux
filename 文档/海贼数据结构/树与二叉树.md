## 树

**树的节点代表集合,边代表关系**

- 链表可以说是特殊的树(一叉树)

- 深度,高度和度

  - 深度:从根节点数到该节点的个数
  - 高度:从该节点数到叶子节点
  - 树的边数别点数

  - 二叉树中,度为0的节点比度为2的节点多一个

- 遍历

  - 前序,中序,后序
  - 左右子树的相对顺序不变

- 完全二叉树

  - 叶子节点只缺少右节点
  - 完全二叉树中不需要存子节点地址(因为知道根节点后,左孩子`2i`,右孩子`2i+1`,只需要存关键的数据信息.
  - 可以使用数组存储,且不需要存储边的信息
  - 记录式改计算式,会节省大量存储空间
    - 重要的算法优化手段.

- 满二叉树

  - 没有度为0的节点
  - 例如:Huffman树

- 完美二叉树

#### 求树的最近公共祖先

- 求出后可用来求两节点的最短路径
  - 例如a,b的最近公共祖先为c,`deep(a)+deep(b)-2*deep(c)`





## Leetcode

- 20
  - 改成递归写法
- 232 用两个栈模拟一个队列
- 225 用队列模拟栈
- **102**
  - 传出参数,将变量地址传入
- 104
- 107
  - 根节点放在最后一行
- 110

```c
// 方法1, 存在重复计算
int getHeight(struct TreeNode *root) {
    if (root == NULL) return 0;
    int l = getHeight(root->left), r = getHeight(root->right);
    return (l > r ? l : r) + 1;
}

bool isBalanced(struct TreeNode* root) {
    if (root == NULL) return true;
    int l = getHeight(root->left), r = getHeight(root->right);
    if (fabs(l - r) > 1) return false;
    return isBalanced(root->left) && isBalanced(root->right);
}
// 方法2
为何不平衡时返回-2
```

- 226
- 235
  - 当在递归结构中设计要存储的信息时,要精心考虑
- 257
- 297
  - 二叉树的广义表的解析

## 计蒜客

- B树, 所有叶子节点处在同一层
  - n阶B树每个节点可存储n-1个节点
- 将树转化为二叉树,左孩子右兄弟
- 线索化二叉树
  - 将二叉树做成链表的形式,不借用递归去遍历二叉树
  - 线索化
  - 每个节点添加标志位`ltag rtag`
    - `ltag=1`代表为线索化的边(无左子树)
  - 中序遍历线索化
    1. 如果有左孩子,一直往左走
    2. 输出当前key
    3. 如果有右孩子,向右走一步,回到1
    4. 如果没有右孩子,沿右线索走,回到2
  - 做完了线索化的二叉树本质上是个双向链表

#### 广义表



#### 石子合并

#### 编码

- 用变长编码方式时,只有叶子节点可作为字符,因为非叶子节点的编码会导致识别出错,(每个编码不能为任何编码的前缀)
- 哈弗曼编码:最优变长编码

#### 行动路线

- 将目标转化为一个个阶段来实现

- 在定目标时当时的估计是不准确的,应该定一个比预期高的目标

## 经验及总结

- 当把根节点的地址传入函数时,在函数内对地址指向的改变,函数外不受影响,对地址指向内存中值的改变才受影响,切记

#### 问题

- 如何输出二叉链表的广义表形式