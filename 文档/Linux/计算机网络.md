端口:0-65536

soket套接字

TCP协议

	三次握手(建立连接)

	四次挥手(释放连接)

## 网络编程

- 主机字节序与网络字节序
  - 在将一个地址绑定到socket的时候,先将主机字节序转化为网络字节序.

create

 建立新套接字,bind listen

父进程和子进程执行同一片代码块

	子进程pid=0

server:

	192.168.1.40
	
	端口:8731

`perror("")`

- socket() 创建socket

```c
int socket(int domain, int type, int protool)
domain: AF_INET...
type: SOCK_STREAM...
```

- bind()绑定IP地址及端口

```c
int bind(sockfd, const struct sockaddr *addr, socketlen_t addrlen)
sockfd是调用socket返回的文件描述符
addr是只想数据结构sockaddr的指针,保存你的地址(即端口和IP地址)信息
addrlen设置为sizeof(struct sock)
```

- 相关结构体

```c
struct sockaddr_in{
    sa_family_t sin_family;
    in_port_t sin_portl
    struct in_addr sin_addr;
}
struct in_addr{
   uint32_t s_addr;
}
```

- 

```c
htons()将端口号由主机字节序转换为网络字节序的整数值
	myaddr.sin_port = htons(8731)
ntohl()相反
inet_addr()将一个IP字符串转换为一个网络字节序的整数值
	sockaddr_in.sin_addr.s_addr = inet_addr("192.168.1.2")
inet_ntoa()将一个sin_addr结构体输出成字符串
inet_aton(server_addr_string, &myaddr.sin_addr)
// 尝试转换由strptr所指的字符串,并通过addrptr存放二进制结果
int inet_pton(int family, const char *strptr, void *addrptr)

// 进行相反转换,从数值格式转换到表达格式
const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len)

```

- listen()监听socket

```c
int listen(int sockfd, int backlog);
```

- connect()建立连接

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
addr是保存着目的地端口和IP地址的数据结构
```

- accept()接收连接 **产生新socket**

```c
int accpet(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
当有连线进来时,accept()会返回一个新的socket处理代码,往后的数据传送与读取都是经由新的socket处理
```

- close()关闭连接

`int close(int fd)`